<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-基于ReactNative和Realm的开源项目" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/01/基于ReactNative和Realm的开源项目/" class="article-date">
  <time datetime="2016-12-01T11:27:18.000Z" itemprop="datePublished">2016-12-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/01/基于ReactNative和Realm的开源项目/">自定义相机遇到的坑总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="通用的问题"><a href="#通用的问题" class="headerlink" title="通用的问题"></a>通用的问题</h2><p>因为我要做的是一个高度定制（只有前置摄像头并且整个项目activity都是禁止翻转的）的相机，相机的surfaceview的宽度和高度都不是屏幕的高度和宽度，所以相机的preview（预览）和picture（拍照）都会有问题，有时候发现preview中的图像变形，或者拍出来的照片及其模糊，还有一些其他问题。今天把做这个项目中遇到的坑都给趴出来。</p>
<p><strong>setPreviewSize和setPictureSize</strong><br>之前做法，paramerters.getSupportedPreviewSizes和parameters.getSupportedPictureSizes，获取一个list<size>，从里面找出最大的width<em>height，然后设置setPreviewSize和setPictureSize，这种情况，对于surfaceview是全屏的情况下，是没发现什么问题的。但是如果surfaceview不是全屏的情况下呢？<br>这种情况，找到一种最合适的解决方案，算出surfaceview的width/height，然后遍历整个paramerters.getSupportedPreviewSizes和parameters.getSupportedPictureSizes的width/height，找出最接近的比例，这就是最核心的算法。<br>好了，算法找出来之后，我们就要开始进一步优化了。<br><strong>遇到过的坑：</strong><br>1）好了，算法写好了，我们就开始测试了，发现相机预览的时候，图像还是有拉伸，这是为什么咧？<br>为了解决这个问题，我把所有的支持的preview的图片全都打印出来，发现其中有很多size，width &gt; height，而我们的surfaceview是width &lt; height，这是一个坑，所以我们在进行核心算法之前，我们要遍历list，目的是要先将获取的previewsize的list中的size中的width和height全部变成width &gt; height，然后返回一个我们需要在后面算法遍历的list。同理，picturesize也是要同样处理。<br>2）使用上面新的算法的时候，发现预览的时候，发现特别模糊。<br>这个原因，一下就可以猜测到，我们选取preview size的时候，虽然找到最接近sufaceview的width/height，但是这个像素点太低了。所以我又将support preview size以及width/height又给打了一遍，发现其实有两个size是比例相近的，其中一个size像素比较高，但是为啥选了低的那个咧？<br>很明显，这个support list是乱序的，选到一个最合适的，就是它了。所以，开始还需要将这个list排序一波，从大到小，这样的话，就算list中有好几个比例最接近sufaceview的，我们也是找到最大像素的size。同时呢，为了防止图片像素太低，我又加了一个判断，少于480 </em> 320（实验得到的），就可以直接break出来了，这样也能保证比较高的像素点，还能减少时间复杂度。<br>3）遗留问题，三星<br>三星拍出来的照片是反的，开始以为是width&gt;heigth的原因，验证得到，setRoutation失败。<br>开始以为是preview和picture的width&gt;height，然后就在想改变surfaceview或者其他方法，后来发现，其他手机width&gt;height，最终才知道，原来是三星手机setRoutation没作用。<br>至今没有解决。</size></p>
<h2 id="个别手机问题"><a href="#个别手机问题" class="headerlink" title="个别手机问题"></a>个别手机问题</h2><p><strong>设置自动对焦</strong></p>
<p>好了，设置好preview和picture的size之后，图像就不会出现变形或者其他状况了，但是我们发现这样的话，看起来模糊，这是为啥咧？原来我们没有设置自动对焦，好，那我们就设置自动对焦，这样又趴出阿里一些坑，而且都是个别手机的问题。<br>我们都知道设置自动对焦代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);</div><div class="line">mCamera.autoFocus(new Camera.AutoFocusCallback() &#123;</div><div class="line">                        @Override</div><div class="line">                        public void onAutoFocus(boolean b, Camera camera) &#123;</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div></pre></td></tr></table></figure>
<p>好了，然后我们就用手机测试一波。</p>
<p><strong>三星手机</strong></p>
<p>出现了这个问题：<br><img src="http://img.blog.csdn.net/20161201202958454" alt="这里写图片描述"></p>
<p>三星手机，在执行，autofus方法的时候崩溃了（这里涉及到native中的代码，太难了，所以没有去看源码）。当时猜测可能是相机还没完全初始化好，就开始自动对焦，就会崩溃，所以这个方法延时两秒执行，然后就可以了。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">handler.postDelayed(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                try &#123;</div><div class="line">                    mCamera.autoFocus(new Camera.AutoFocusCallback() &#123;</div><div class="line">                        @Override</div><div class="line">                        public void onAutoFocus(boolean b, Camera camera) &#123;</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125; catch (RuntimeException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, 2000);</div></pre></td></tr></table></figure>
<p><strong>猜测原因：</strong><br>部分手机camera初始化耗时长，还没初始好，就设置自动对焦可能就出现问题了。自动对焦延时对焦，对相机来说没有什么影响，所以这种方法可以适用于其他手机类型。</p>
<p><strong>小米手机</strong><br>红米米手机设置parameters.setFocusMode自动对焦，会直接蹦掉。log如下：<br><img src="http://img.blog.csdn.net/20161201203612362" alt="这里写图片描述"></p>
<p>这个log根本看不出问题出在哪里，不过幸好的时候，我直接没有设置过自动对焦，而且小米手机没有发生过崩溃，所以就大胆猜测这个问题出在设置自动对焦的时候，最终定位到setFocusMode方法中。<br>做了如下处理：（红米手机所支持的FoucusMode的类型中，没有auto类型，所以setParameters的时候会出错）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; focusModes = parameters.getSupportedFocusModes();</div><div class="line">for (String mode : focusModes) &#123;</div><div class="line">            if (mode.equals(Camera.Parameters.FOCUS_MODE_AUTO)) &#123;</div><div class="line">                parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/01/基于ReactNative和Realm的开源项目/" data-id="ciw6kx7ok000p00ugwq5do1dz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/camera/">camera</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/native/">native</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-自定义相机踩过的坑" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/01/自定义相机踩过的坑/" class="article-date">
  <time datetime="2016-12-01T08:36:18.000Z" itemprop="datePublished">2016-12-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/01/自定义相机踩过的坑/">自定义相机踩过的坑</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="通用的问题"><a href="#通用的问题" class="headerlink" title="通用的问题"></a>通用的问题</h2><p>因为我要做的是一个高度定制（只有前置摄像头并且整个项目activity都是禁止翻转的）的相机，相机的surfaceview的宽度和高度都不是屏幕的高度和宽度，所以相机的preview（预览）和picture（拍照）都会有问题，有时候发现preview中的图像变形，或者拍出来的照片及其模糊，还有一些其他问题。今天把做这个项目中遇到的坑都给趴出来。</p>
<p><strong>setPreviewSize和setPictureSize</strong><br>之前做法，paramerters.getSupportedPreviewSizes和parameters.getSupportedPictureSizes，获取一个list<size>，从里面找出最大的width<em>height，然后设置setPreviewSize和setPictureSize，这种情况，对于surfaceview是全屏的情况下，是没发现什么问题的。但是如果surfaceview不是全屏的情况下呢？<br>这种情况，找到一种最合适的解决方案，算出surfaceview的width/height，然后遍历整个paramerters.getSupportedPreviewSizes和parameters.getSupportedPictureSizes的width/height，找出最接近的比例，这就是最核心的算法。<br>好了，算法找出来之后，我们就要开始进一步优化了。<br><strong>遇到过的坑：</strong><br>1）好了，算法写好了，我们就开始测试了，发现相机预览的时候，图像还是有拉伸，这是为什么咧？<br>为了解决这个问题，我把所有的支持的preview的图片全都打印出来，发现其中有很多size，width &gt; height，而我们的surfaceview是width &lt; height，这是一个坑，所以我们在进行核心算法之前，我们要遍历list，目的是要先将获取的previewsize的list中的size中的width和height全部变成width &gt; height，然后返回一个我们需要在后面算法遍历的list。同理，picturesize也是要同样处理。<br>2）使用上面新的算法的时候，发现预览的时候，发现特别模糊。<br>这个原因，一下就可以猜测到，我们选取preview size的时候，虽然找到最接近sufaceview的width/height，但是这个像素点太低了。所以我又将support preview size以及width/height又给打了一遍，发现其实有两个size是比例相近的，其中一个size像素比较高，但是为啥选了低的那个咧？<br>很明显，这个support list是乱序的，选到一个最合适的，就是它了。所以，开始还需要将这个list排序一波，从大到小，这样的话，就算list中有好几个比例最接近sufaceview的，我们也是找到最大像素的size。同时呢，为了防止图片像素太低，我又加了一个判断，少于480 </em> 320（实验得到的），就可以直接break出来了，这样也能保证比较高的像素点，还能减少时间复杂度。<br>3）遗留问题，三星<br>三星拍出来的照片是反的，开始以为是width&gt;heigth的原因，验证得到，setRoutation失败。<br>开始以为是preview和picture的width&gt;height，然后就在想改变surfaceview或者其他方法，后来发现，其他手机width&gt;height，最终才知道，原来是三星手机setRoutation没作用。<br>至今没有解决。</size></p>
<h2 id="个别手机问题"><a href="#个别手机问题" class="headerlink" title="个别手机问题"></a>个别手机问题</h2><p><strong>设置自动对焦</strong></p>
<p>好了，设置好preview和picture的size之后，图像就不会出现变形或者其他状况了，但是我们发现这样的话，看起来模糊，这是为啥咧？原来我们没有设置自动对焦，好，那我们就设置自动对焦，这样又趴出阿里一些坑，而且都是个别手机的问题。<br>我们都知道设置自动对焦代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);</div><div class="line">mCamera.autoFocus(new Camera.AutoFocusCallback() &#123;</div><div class="line">                        @Override</div><div class="line">                        public void onAutoFocus(boolean b, Camera camera) &#123;</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div></pre></td></tr></table></figure>
<p>好了，然后我们就用手机测试一波。</p>
<p><strong>三星手机</strong></p>
<p>出现了这个问题：<br><img src="http://img.blog.csdn.net/20161201202958454" alt="这里写图片描述"></p>
<p>三星手机，在执行，autofus方法的时候崩溃了（这里涉及到native中的代码，太难了，所以没有去看源码）。当时猜测可能是相机还没完全初始化好，就开始自动对焦，就会崩溃，所以这个方法延时两秒执行，然后就可以了。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">handler.postDelayed(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                try &#123;</div><div class="line">                    mCamera.autoFocus(new Camera.AutoFocusCallback() &#123;</div><div class="line">                        @Override</div><div class="line">                        public void onAutoFocus(boolean b, Camera camera) &#123;</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125; catch (RuntimeException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, 2000);</div></pre></td></tr></table></figure>
<p><strong>猜测原因：</strong><br>部分手机camera初始化耗时长，还没初始好，就设置自动对焦可能就出现问题了。自动对焦延时对焦，对相机来说没有什么影响，所以这种方法可以适用于其他手机类型。</p>
<p><strong>小米手机</strong><br>红米米手机设置parameters.setFocusMode自动对焦，会直接蹦掉。log如下：<br><img src="http://img.blog.csdn.net/20161201203612362" alt="这里写图片描述"></p>
<p>这个log根本看不出问题出在哪里，不过幸好的时候，我直接没有设置过自动对焦，而且小米手机没有发生过崩溃，所以就大胆猜测这个问题出在设置自动对焦的时候，最终定位到setFocusMode方法中。<br>做了如下处理：（红米手机所支持的FoucusMode的类型中，没有auto类型，所以setParameters的时候会出错）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; focusModes = parameters.getSupportedFocusModes();</div><div class="line">for (String mode : focusModes) &#123;</div><div class="line">            if (mode.equals(Camera.Parameters.FOCUS_MODE_AUTO)) &#123;</div><div class="line">                parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/01/自定义相机踩过的坑/" data-id="ciw6kx7os001000ugwbaper3x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/camera/">camera</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/native/">native</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-微信小程序学习资料汇总" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/26/微信小程序学习资料汇总/" class="article-date">
  <time datetime="2016-09-26T06:56:18.000Z" itemprop="datePublished">2016-09-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Weapp/">Weapp</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/26/微信小程序学习资料汇总/">微信小程序学习资料汇总</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://gold.xitu.io/post/57e484f875c4cd2d9f345f8a" target="_blank" rel="external">微信小程序开发环境搭建</a><br><a href="http://wxopen.notedown.cn/" target="_blank" rel="external">微信教程</a><br><a href="http://www.jianshu.com/p/060c6f3dd4e8" target="_blank" rel="external">微信小程序，一个有局限的类似 React Native 轮子！</a><br><a href="https://github.com/gavinkwoe/weapp-ide-crack" target="_blank" rel="external">微信应用号/小程序开发IDE</a><br><a href="http://mp.weixin.qq.com/s?__biz=MjM5Mjg4NDMwMA==&amp;mid=2652974082&amp;idx=1&amp;sn=47c7f672caf629cd846e315b8df2b1c5&amp;scene=21#wechat_redirect" target="_blank" rel="external">微信小程序「官方示例代码」浅析【上】</a><br><a href="http://mp.weixin.qq.com/s?__biz=MjM5Mjg4NDMwMA==&amp;mid=2652974093&amp;idx=1&amp;sn=0570a243304ea8bb7d1b636624886fb1&amp;scene=21#wechat_redirect" target="_blank" rel="external">微信小程序剖析【下】：运行机制</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/26/微信小程序学习资料汇总/" data-id="ciw6kx7om000s00ug3b3q66ew" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/app/">app</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weChat/">weChat</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-一个自定义的GridLayout" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/26/一个自定义的GridLayout/" class="article-date">
  <time datetime="2016-09-26T03:36:18.000Z" itemprop="datePublished">2016-09-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/26/一个自定义的GridLayout/">一个自定义的GridLayout</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这段时间，因为工作上业务需求，所以自己自定义了一个类似于GridView的viewgroup，源码和例子在<a href="https://github.com/LonerJimmy/GridLayoutExample" target="_blank" rel="external">https://github.com/LonerJimmy/GridLayoutExample</a><br>有兴趣的同学可以来参考一下，有问题的话，希望大家多多提意见。<br>使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">&lt;loner.library.gridlayout.GridLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;200dp&quot;</div><div class="line">        android:background=&quot;@color/colorAccent&quot;</div><div class="line">        android:paddingTop=&quot;20dp&quot;</div><div class="line">        app:horizontalSpacing=&quot;10dp&quot;</div><div class="line">        app:numRows=&quot;4&quot;</div><div class="line">        app:verticalSpacing=&quot;10dp&quot;&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:layout_width=&quot;10dp&quot;</div><div class="line">            android:layout_height=&quot;10dp&quot;</div><div class="line">            android:background=&quot;#0F0&quot;</div><div class="line">            android:text=&quot;1&quot; /&gt;</div><div class="line">        &lt;TextView</div><div class="line">            android:layout_width=&quot;20dp&quot;</div><div class="line">            android:layout_height=&quot;20dp&quot;</div><div class="line">            android:background=&quot;#0F0&quot;</div><div class="line">            android:text=&quot;2&quot; /&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:layout_width=&quot;10dp&quot;</div><div class="line">            android:layout_height=&quot;20dp&quot;</div><div class="line">            android:background=&quot;#0F0&quot;</div><div class="line">            android:text=&quot;3&quot; /&gt;</div><div class="line">        &lt;TextView</div><div class="line">            android:layout_width=&quot;20dp&quot;</div><div class="line">            android:layout_height=&quot;30dp&quot;</div><div class="line">            android:background=&quot;#0F0&quot;</div><div class="line">            android:text=&quot;4&quot; /&gt;</div><div class="line">        &lt;TextView</div><div class="line">            android:layout_width=&quot;40dp&quot;</div><div class="line">            android:layout_height=&quot;30dp&quot;</div><div class="line">            android:background=&quot;#0F0&quot;</div><div class="line">            android:text=&quot;5&quot; /&gt;</div><div class="line">        &lt;TextView</div><div class="line">            android:layout_width=&quot;50dp&quot;</div><div class="line">            android:layout_height=&quot;50dp&quot;</div><div class="line">            android:background=&quot;#0F0&quot;</div><div class="line">            android:text=&quot;6&quot; /&gt;</div><div class="line">        &lt;TextView</div><div class="line">            android:layout_width=&quot;50dp&quot;</div><div class="line">            android:layout_height=&quot;50dp&quot;</div><div class="line">            android:background=&quot;#0F0&quot;</div><div class="line">            android:text=&quot;7&quot; /&gt;</div><div class="line">        &lt;TextView</div><div class="line">            android:layout_width=&quot;30dp&quot;</div><div class="line">            android:layout_height=&quot;50dp&quot;</div><div class="line">            android:background=&quot;#0F0&quot;</div><div class="line">            android:text=&quot;7&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;/loner.library.gridlayout.GridLayout&gt;</div></pre></td></tr></table></figure>
<p>在values/attrs.xml中声明下面的resource：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;resources&gt;</div><div class="line">    &lt;declare-styleable name=&quot;GridLayoutAttrs&quot;&gt;</div><div class="line">        &lt;attr name=&quot;horizontalSpacing&quot; format=&quot;dimension&quot; /&gt;</div><div class="line">        &lt;attr name=&quot;verticalSpacing&quot; format=&quot;dimension&quot; /&gt;</div><div class="line">        &lt;attr name=&quot;numColumns&quot; format=&quot;integer&quot; /&gt;</div><div class="line">        &lt;attr name=&quot;numRows&quot; format=&quot;integer&quot; /&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
<p>通过这几个resource来控制布局，horizontalSpacing是水平方向上每列的间距，verticalSpacing是垂直方向上每列的间距，numColumns是列数，numRows是行数，这里要注意的是：<br>1、numColumns和numRows可以都声明，但是你的view数目要&gt;=numColumns*numRows，否则会抛异常。这里布局跟gridview布局一样，以行为来排列。<br>2、你也可以只声明numColumns和numRows其中一个，但是如果只声明其中一个的话，这里布局就会跟着列或者行来进行布局。如果我说的比较抽象，大家可以去上面我的github上的例子去试一下。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/26/一个自定义的GridLayout/" data-id="ciw6kx7oa000h00ugaziczcpi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gridview/">gridview</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/viewgroup/">viewgroup</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LayoutInflater原理解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/13/LayoutInflater原理解析/" class="article-date">
  <time datetime="2016-09-13T09:50:18.000Z" itemprop="datePublished">2016-09-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/13/LayoutInflater原理解析/">深入了解View（一）——LayoutInflater原理分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一直想要深入了解一下view的工作原理，现在有时间空出来了，所以就着手准备了解一下，首先先看一下LayoutInflater的原理。<br>相信大家对LayoutInflater一定不陌生，我们在加载布局的时候通常都会用到这个，一开始对LayoutInflater也不是很了解，因为我们平时用的都是setContentView方法，今天查了一些资料才知道，原来setContentView方法内部也是用LayoutInflater来实现的。<br>先看看LayoutInflater的使用方法吧，首先需要获取LayoutInflater的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LayoutInflater layoutInflater = LayoutInflater.from(context);</div></pre></td></tr></table></figure>
<p>得到LayoutInflater实例之后，我们就可以使用其中的inflate方法来加载布局了，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">layoutInflater.inflate(resourceId, root);</div></pre></td></tr></table></figure>
<p>inflate方法中有两个参数，第一个就是需要加载布局的id，第二个就是需要给该布局外部再嵌套一层父布局，如果不需要的话，我们就传一个null就可以了。</p>
<p>用法就介绍到这里，我们看一下inflate方法到底是如何实现的。<br>最终跳转到的inflate方法源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</div><div class="line">       synchronized (mConstructorArgs) &#123;</div><div class="line">           Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);</div><div class="line"></div><div class="line">           final Context inflaterContext = mContext;</div><div class="line">           final AttributeSet attrs = Xml.asAttributeSet(parser);</div><div class="line">           Context lastContext = (Context) mConstructorArgs[0];</div><div class="line">           mConstructorArgs[0] = inflaterContext;</div><div class="line">           View result = root;</div><div class="line"></div><div class="line">           try &#123;</div><div class="line">               // Look for the root node.</div><div class="line">               int type;</div><div class="line">               while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</div><div class="line">                       type != XmlPullParser.END_DOCUMENT) &#123;</div><div class="line">                   // Empty</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               if (type != XmlPullParser.START_TAG) &#123;</div><div class="line">                   throw new InflateException(parser.getPositionDescription()</div><div class="line">                           + &quot;: No start tag found!&quot;);</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               final String name = parser.getName();</div><div class="line">               </div><div class="line">               if (DEBUG) &#123;</div><div class="line">                   System.out.println(&quot;**************************&quot;);</div><div class="line">                   System.out.println(&quot;Creating root view: &quot;</div><div class="line">                           + name);</div><div class="line">                   System.out.println(&quot;**************************&quot;);</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               if (TAG_MERGE.equals(name)) &#123;</div><div class="line">                   if (root == null || !attachToRoot) &#123;</div><div class="line">                       throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;</div><div class="line">                               + &quot;ViewGroup root and attachToRoot=true&quot;);</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   rInflate(parser, root, inflaterContext, attrs, false);</div><div class="line">               &#125; else &#123;</div><div class="line">                   // Temp is the root view that was found in the xml</div><div class="line">                   final View temp = createViewFromTag(root, name, inflaterContext, attrs);</div><div class="line"></div><div class="line">                   ViewGroup.LayoutParams params = null;</div><div class="line"></div><div class="line">                   if (root != null) &#123;</div><div class="line">                       if (DEBUG) &#123;</div><div class="line">                           System.out.println(&quot;Creating params from root: &quot; +</div><div class="line">                                   root);</div><div class="line">                       &#125;</div><div class="line">                       // Create layout params that match root, if supplied</div><div class="line">                       params = root.generateLayoutParams(attrs);</div><div class="line">                       if (!attachToRoot) &#123;</div><div class="line">                           // Set the layout params for temp if we are not</div><div class="line">                           // attaching. (If we are, we use addView, below)</div><div class="line">                           temp.setLayoutParams(params);</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   if (DEBUG) &#123;</div><div class="line">                       System.out.println(&quot;-----&gt; start inflating children&quot;);</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   // Inflate all children under temp against its context.</div><div class="line">                   rInflateChildren(parser, temp, attrs, true);</div><div class="line"></div><div class="line">                   if (DEBUG) &#123;</div><div class="line">                       System.out.println(&quot;-----&gt; done inflating children&quot;);</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   // We are supposed to attach all the views we found (int temp)</div><div class="line">                   // to root. Do that now.</div><div class="line">                   if (root != null &amp;&amp; attachToRoot) &#123;</div><div class="line">                       root.addView(temp, params);</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   // Decide whether to return the root that was passed in or the</div><div class="line">                   // top view found in xml.</div><div class="line">                   if (root == null || !attachToRoot) &#123;</div><div class="line">                       result = temp;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">           &#125; catch (XmlPullParserException e) &#123;</div><div class="line">               InflateException ex = new InflateException(e.getMessage());</div><div class="line">               ex.initCause(e);</div><div class="line">               throw ex;</div><div class="line">           &#125; catch (Exception e) &#123;</div><div class="line">               InflateException ex = new InflateException(</div><div class="line">                       parser.getPositionDescription()</div><div class="line">                               + &quot;: &quot; + e.getMessage());</div><div class="line">               ex.initCause(e);</div><div class="line">               throw ex;</div><div class="line">           &#125; finally &#123;</div><div class="line">               // Don&apos;t retain static reference on context.</div><div class="line">               mConstructorArgs[0] = lastContext;</div><div class="line">               mConstructorArgs[1] = null;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line"></div><div class="line">           return result;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><strong>从源码中我们可以看出，LayoutInflate其实就是利用android pull解析方法来解析布局文件的。</strong><br>这个代码很多，但是我们抓住几行重要的函数看一下就可以大概了解工作机制了，其中调用了createViewFromTag()方法，将节点名和参数传进去，我们看一下createViewFromTag实现的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">View view;</div><div class="line">if (mFactory2 != null) &#123;</div><div class="line">    view = mFactory2.onCreateView(parent, name, context, attrs);</div><div class="line">&#125; else if (mFactory != null) &#123;</div><div class="line">    view = mFactory.onCreateView(name, context, attrs);</div><div class="line">&#125; else &#123;</div><div class="line">    view = null;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (view == null &amp;&amp; mPrivateFactory != null) &#123;</div><div class="line">    view = mPrivateFactory.onCreateView(parent, name, context, attrs);</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (view == null) &#123;</div><div class="line">    final Object lastContext = mConstructorArgs[0];</div><div class="line">    mConstructorArgs[0] = context;</div><div class="line">    try &#123;</div><div class="line">        if (-1 == name.indexOf(&apos;.&apos;)) &#123;</div><div class="line">            view = onCreateView(parent, name, attrs);</div><div class="line">        &#125; else &#123;</div><div class="line">            view = createView(name, null, attrs);</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        mConstructorArgs[0] = lastContext;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return view;</div></pre></td></tr></table></figure>
<p>这里面，又调用了createView方法，然后使用反射的方式创建出view示例，然后返回。实际上就是根据节点创建了一个view对象，但是这里只是创建一个根布局实例而已，后面又调用rInflate()方法，遍历这个跟布局的子元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">void rInflate(XmlPullParser parser, View parent, Context context,</div><div class="line">            AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123;</div><div class="line"></div><div class="line">        final int depth = parser.getDepth();</div><div class="line">        int type;</div><div class="line"></div><div class="line">        while (((type = parser.next()) != XmlPullParser.END_TAG ||</div><div class="line">                parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</div><div class="line"></div><div class="line">            if (type != XmlPullParser.START_TAG) &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            final String name = parser.getName();</div><div class="line">            </div><div class="line">            if (TAG_REQUEST_FOCUS.equals(name)) &#123;</div><div class="line">                parseRequestFocus(parser, parent);</div><div class="line">            &#125; else if (TAG_TAG.equals(name)) &#123;</div><div class="line">                parseViewTag(parser, parent, attrs);</div><div class="line">            &#125; else if (TAG_INCLUDE.equals(name)) &#123;</div><div class="line">                if (parser.getDepth() == 0) &#123;</div><div class="line">                    throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);</div><div class="line">                &#125;</div><div class="line">                parseInclude(parser, context, parent, attrs);</div><div class="line">            &#125; else if (TAG_MERGE.equals(name)) &#123;</div><div class="line">                throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);</div><div class="line">            &#125; else &#123;</div><div class="line">                final View view = createViewFromTag(parent, name, context, attrs);</div><div class="line">                final ViewGroup viewGroup = (ViewGroup) parent;</div><div class="line">                final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);</div><div class="line">                rInflateChildren(parser, view, attrs, true);</div><div class="line">                viewGroup.addView(view, params);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (finishInflate) &#123;</div><div class="line">            parent.onFinishInflate();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里其实是一个递归方法，调用createViewFromTag创建view实例，然后rInflate方法查找这个view下面的子元素，每次递归完成后将这个view添加到父布局中。这样将整个你要添加的布局都解析完成，形成一个完整的DOM结构，然后将最顶层的根布局返回。<br>我们再来看看inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)中的参数的含义，可以看一下这个代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (root == null || !attachToRoot) &#123;</div><div class="line">                        throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;</div><div class="line">                                + &quot;ViewGroup root and attachToRoot=true&quot;);</div><div class="line">                    &#125;</div></pre></td></tr></table></figure>
<p>所以得到的结论如下：<br><strong>1. 如果root为null，attachToRoot将失去作用，设置任何值都没有意义。</strong><br><strong>2. 如果root不为null，attachToRoot设为true，则会给加载的布局文件的指定一个父布局，即root。</strong><br><strong>3. 如果root不为null，attachToRoot设为false，则会将布局文件最外层的所有layout属性进行设置，当该view被添加到父view当中时，这些layout属性会自动生效。</strong></p>
<p>介绍到这里，我们对layoutInflate应该有大致的了解了吧！除此之外，通过看一些资料，我发现了一些以前没有注意过的东西。当我们在使用layoutInflater的时候，如果将一个只有button的布局加到viewgroup中，无论我们怎么设置button的layout_width和layout_height，添加到viewgroup中的button的大小都没改变，这是为啥咧？<br>那是因为button控件不存在任何布局中，如果你在button哪个xml中外面再包一层relativeLayout，就可以改变button的大小了。<br>补充：其实平时我们使用的setContentView方法中，我们自定义的布局为什么设置layout_width和layout_height是ok的呢，原来setContentView中在我们布局外面又嵌套了一层Framelayout，哈哈！</p>
<p>好了，今天就聊到这里，要继续苦逼做业务需求了！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/13/LayoutInflater原理解析/" data-id="ciw6kx7nf000100ugilxdxlxi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/inflater/">inflater</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/layout/">layout</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/布局/">布局</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Glide深入浅出(二)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/08/Glide深入浅出(二)/" class="article-date">
  <time datetime="2016-09-08T11:19:18.000Z" itemprop="datePublished">2016-09-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/08/Glide深入浅出(二)/">Glide深入浅出（二）——源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们先来看看glide最基本使用方式，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Glide.with(this)</div><div class="line">                .asDrawable()</div><div class="line">                .load(&quot;http://i6.topit.me/6/5d/45/1131907198420455d6o.jpg&quot;)</div><div class="line">                .apply(fitCenterTransform(this))</div><div class="line">                .apply(placeholderOf(R.drawable.skyblue_logo_wechatfavorite_checked))</div><div class="line">                .into(imageView);</div></pre></td></tr></table></figure>
<p>本片文章就从这个最简单的使用方法来对源码进行一波解析。</p>
<h2 id="一、大概介绍"><a href="#一、大概介绍" class="headerlink" title="一、大概介绍"></a>一、大概介绍</h2><p><strong>Glide.java 入口文件</strong></p>
<p>这里其实就是一个入口文件，所有功能都是放在后面的类中，这里所有需要的组件都在这个文件里面进行统一初始化。</p>
<p><strong>RequestManager.java</strong></p>
<p>这个类主要是用于管理和启动glide的所有请求，可以使用activity，fragment或者连接生命周期的事件去只能的停止，启动和重启请求。也可以检索或者通过实例化一个新的对象，或者使用静态的glide去利用构建在activity和fragment生命周期处理中。它的方法跟你的fragment和activity是同步的。</p>
<p><strong>RequestBuilder.java</strong></p>
<p>可以处理设置选项，并启动负载的通用资源类型。</p>
<p>看前面的例子代码中，asDrawable()最终调用的的RequestBuilder中的transition()函数，这个方法主要是用于加载对象从占位符(placeholder)或者缩略图(thumbnail)到真正对象加载完成的专场动画。</p>
<p>load()方法中，这里可以加载很多类型的数据对象，可以是string，uri，file，resourceId，byte[]这些。对应的编码方式也是不一样的。</p>
<p>into()方法，是真正启动加载的地方。</p>
<h2 id="二、具体源码解析"><a href="#二、具体源码解析" class="headerlink" title="二、具体源码解析"></a>二、具体源码解析</h2><p><strong>Glide.with()函数</strong></p>
<p>先看一下glide中的with函数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static RequestManager with(Activity activity) &#123;</div><div class="line">  RequestManagerRetriever retriever = RequestManagerRetriever.get();</div><div class="line">  return retriever.get(activity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里返回的是RequestManagerRetriever.get()，我们看一下这个函数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@TargetApi(Build.VERSION_CODES.HONEYCOMB)</div><div class="line">  public RequestManager get(Activity activity) &#123;</div><div class="line">    if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">      return get(activity.getApplicationContext());</div><div class="line">    &#125; else &#123;</div><div class="line">      assertNotDestroyed(activity);</div><div class="line">      android.app.FragmentManager fm = activity.getFragmentManager();</div><div class="line">      return fragmentGet(activity, fm, null);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>（当然这个with()可以传很多类型进来，我们只看activity的情况）<br>源码中，如果该activity在后台的时候，我们进入get(Application)中，继续我们刚刚说的这个步骤来。<br>所以我们就直接看fragmentGet(activity, fm, null)函数，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@TargetApi(Build.VERSION_CODES.HONEYCOMB)</div><div class="line">  RequestManager fragmentGet(Context context, android.app.FragmentManager fm,</div><div class="line">      android.app.Fragment parentHint) &#123;</div><div class="line">    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);</div><div class="line">    RequestManager requestManager = current.getRequestManager();</div><div class="line">    if (requestManager == null) &#123;</div><div class="line">      // TODO(b/27524013): Factor out this Glide.get() call.</div><div class="line">      Glide glide = Glide.get(context);</div><div class="line">      requestManager =</div><div class="line">          new RequestManager(glide, current.getLifecycle(), current.getRequestManagerTreeNode());</div><div class="line">      current.setRequestManager(requestManager);</div><div class="line">    &#125;</div><div class="line">    return requestManager;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这个函数作用正如它的名字一样，就是获取fragment，其实是返回的RequestManager，那这个到底是啥？看一下getRequestManagerFragment函数，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)</div><div class="line">RequestManagerFragment getRequestManagerFragment(</div><div class="line">    final android.app.FragmentManager fm, android.app.Fragment parentHint) &#123;</div><div class="line">  RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</div><div class="line">  if (current == null) &#123;</div><div class="line">    current = pendingRequestManagerFragments.get(fm);</div><div class="line">    if (current == null) &#123;</div><div class="line">      current = new RequestManagerFragment();</div><div class="line">      current.setParentFragmentHint(parentHint);</div><div class="line">      pendingRequestManagerFragments.put(fm, current);</div><div class="line">      fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</div><div class="line">      handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return current;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（其中传进来的参数fm，是我们获取的activity的FragmentManager）<br>这里其实就是就是将我们传进来的activity转化为glide需要的RequestManagerFragment，RequestManagerFragment是一个自己重新以的fragment而已。</p>
<p><strong>asDrawable函数</strong></p>
<p>源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public RequestBuilder&lt;Drawable&gt; asDrawable() &#123;</div><div class="line">  return as(Drawable.class).transition(new DrawableTransitionOptions());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>添加一个DrawableTransitionOptions类型的动画。</p>
<p><strong>load函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public RequestBuilder&lt;Drawable&gt; load(@Nullable Object model) &#123;</div><div class="line">    return asDrawable().load(model);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">public RequestBuilder&lt;TranscodeType&gt; load(@Nullable Object model) &#123;</div><div class="line">    return loadGeneric(model);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private RequestBuilder&lt;TranscodeType&gt; loadGeneric(@Nullable Object model) &#123;</div><div class="line">    this.model = model;</div><div class="line">    isModelSet = true;</div><div class="line">    return this;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>将你要传递的uri，file等等传进来，放到RequestBuilder中。</p>
<p><strong>into函数</strong></p>
<p>最终我们都要调用这个into了，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public Target&lt;TranscodeType&gt; into(ImageView view) &#123;</div><div class="line">    Util.assertMainThread();</div><div class="line">    Preconditions.checkNotNull(view);</div><div class="line"></div><div class="line">    if (!requestOptions.isTransformationSet()</div><div class="line">        &amp;&amp; requestOptions.isTransformationAllowed()</div><div class="line">        &amp;&amp; view.getScaleType() != null) &#123;</div><div class="line">      if (requestOptions.isLocked()) &#123;</div><div class="line">        requestOptions = requestOptions.clone();</div><div class="line">      &#125;</div><div class="line">      switch (view.getScaleType()) &#123;</div><div class="line">        case CENTER_CROP:</div><div class="line">          requestOptions.optionalCenterCrop(context);</div><div class="line">          break;</div><div class="line">        case CENTER_INSIDE:</div><div class="line">          requestOptions.optionalCenterInside(context);</div><div class="line">          break;</div><div class="line">        case FIT_CENTER:</div><div class="line">        case FIT_START:</div><div class="line">        case FIT_END:</div><div class="line">          requestOptions.optionalFitCenter(context);</div><div class="line">          break;</div><div class="line">        //$CASES-OMITTED$</div><div class="line">        default:</div><div class="line">          // Do nothing.</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return into(context.buildImageViewTarget(view, transcodeClass));</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这里针对ImageView的填充方式做了筛选并对应设置到requestOptions上。最终的是通过ImageView和转码类型（transcodeClass）创建不通过的Target（例如Bitmap对应的BitmapImageViewTarget和Drawable对应的DrawableImageViewTarget）。<br>到这里，我们看到的源码，并没有涉及到解码、缓存、加载等这些功能啊，是不是我们漏掉一些重要的函数？没错，我们的确漏掉一个很重要的函数，在into函数中，有一行代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">requestManager.track(target, request);</div></pre></td></tr></table></figure>
<p>这个就是最核心的方法，它才是真正触发请求、编解码、装载、缓存等这些功能的。下面我详细介绍一下。</p>
<p><strong>track()函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void track(Target&lt;?&gt; target, Request request) &#123;</div><div class="line">    targetTracker.track(target);</div><div class="line">    requestTracker.runRequest(request);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>第一行，就是把target加入targets队列（WeakHashMap）中。<br>看一下runRequest函数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void runRequest(Request request) &#123;</div><div class="line">   requests.add(request);//添加到内存缓存</div><div class="line">   if (!isPaused) &#123;</div><div class="line">     request.begin();//开始</div><div class="line">   &#125; else &#123;</div><div class="line">     pendingRequests.add(request);//挂起请求</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>然后看一下request.begin()是如何运作的，SingleRequest继承一个抽象类，定义了begin方法，所以我们看一下SingleRequest中begin方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">  public void begin() &#123;</div><div class="line">    stateVerifier.throwIfRecycled();</div><div class="line">    startTime = LogTime.getLogTime();</div><div class="line">    // 如果model空的，那么是不能执行的。 这里的model就是前面提到的RequestBuilder中的model</div><div class="line">    if (model == null) &#123;</div><div class="line">      if (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</div><div class="line">        width = overrideWidth;</div><div class="line">        height = overrideHeight;</div><div class="line">      &#125;</div><div class="line">      // Only log at more verbose log levels if the user has set a fallback drawable, because</div><div class="line">      // fallback Drawables indicate the user expects null models occasionally.</div><div class="line">      int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG;</div><div class="line">      onLoadFailed(new GlideException(&quot;Received null model&quot;), logLevel);</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line">    status = Status.WAITING_FOR_SIZE;</div><div class="line">    //如果当前的View尺寸获取到了，就会进入加载流程</div><div class="line">    if (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</div><div class="line">      onSizeReady(overrideWidth, overrideHeight);</div><div class="line">    &#125; else &#123;</div><div class="line">      target.getSize(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//如果等待和正在执行状态，那么当前会加载占位符Drawable</div><div class="line">    if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</div><div class="line">        &amp;&amp; canNotifyStatusChanged()) &#123;</div><div class="line">      target.onLoadStarted(getPlaceholderDrawable());</div><div class="line">    &#125;</div><div class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">      logV(&quot;finished run method in &quot; + LogTime.getElapsedMillis(startTime));</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>看上面注释，如果，当前view尺寸还没有获取到，我们要执行target.getSize(this)函数，我们看一下这个函数实现方法(ViewTarget实现的)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">void getSize(SizeReadyCallback cb) &#123;</div><div class="line">      int currentWidth = getViewWidthOrParam();</div><div class="line">      int currentHeight = getViewHeightOrParam();</div><div class="line">      if (isSizeValid(currentWidth) &amp;&amp; isSizeValid(currentHeight)) &#123;</div><div class="line">        int paddingAdjustedWidth = currentWidth == WindowManager.LayoutParams.WRAP_CONTENT</div><div class="line">            ? currentWidth</div><div class="line">            : currentWidth - ViewCompat.getPaddingStart(view) - ViewCompat.getPaddingEnd(view);</div><div class="line">        int paddingAdjustedHeight = currentHeight == LayoutParams.WRAP_CONTENT</div><div class="line">            ? currentHeight</div><div class="line">            : currentHeight - view.getPaddingTop() - view.getPaddingBottom();</div><div class="line">        cb.onSizeReady(paddingAdjustedWidth, paddingAdjustedHeight);</div><div class="line">      &#125; else &#123;</div><div class="line">        // We want to notify callbacks in the order they were added and we only expect one or two</div><div class="line">        // callbacks to</div><div class="line">        // be added a time, so a List is a reasonable choice.</div><div class="line">        if (!cbs.contains(cb)) &#123;</div><div class="line">          cbs.add(cb);</div><div class="line">        &#125;</div><div class="line">        if (layoutListener == null) &#123;</div><div class="line">        //这是尺寸大小的监听器</div><div class="line">          final ViewTreeObserver observer = view.getViewTreeObserver();          </div><div class="line">          layoutListener = new SizeDeterminerLayoutListener(this);</div><div class="line">          observer.addOnPreDrawListener(layoutListener);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里加了ViewTreeObserver用来监听view尺寸大小，我们可以看看SizeDeterminerLayoutListener做了什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private static class SizeDeterminerLayoutListener implements ViewTreeObserver</div><div class="line">        .OnPreDrawListener &#123;</div><div class="line">      private final WeakReference&lt;SizeDeterminer&gt; sizeDeterminerRef;</div><div class="line"></div><div class="line">      public SizeDeterminerLayoutListener(SizeDeterminer sizeDeterminer) &#123;</div><div class="line">        sizeDeterminerRef = new WeakReference&lt;&gt;(sizeDeterminer);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override</div><div class="line">      public boolean onPreDraw() &#123;</div><div class="line">        if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">          Log.v(TAG, &quot;OnGlobalLayoutListener called listener=&quot; + this);</div><div class="line">        &#125;</div><div class="line">        SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();</div><div class="line">        if (sizeDeterminer != null) &#123;</div><div class="line">        // 通知SizeDeterminer去重新检查尺寸，并触发后续操作。</div><div class="line">          sizeDeterminer.checkCurrentDimens();</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>看完这个getsize，我们再返回到上面begin中的onSizeReady(overrideWidth, overrideHeight)函数，这个才是真正加载的函数。主要是engine发起的load操作，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">  public void onSizeReady(int width, int height) &#123;</div><div class="line">    stateVerifier.throwIfRecycled();</div><div class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">      logV(&quot;Got onSizeReady in &quot; + LogTime.getElapsedMillis(startTime));</div><div class="line">    &#125;</div><div class="line">    if (status != Status.WAITING_FOR_SIZE) &#123;</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line">    status = Status.RUNNING;</div><div class="line"></div><div class="line">    float sizeMultiplier = requestOptions.getSizeMultiplier();</div><div class="line">    this.width = maybeApplySizeMultiplier(width, sizeMultiplier);</div><div class="line">    this.height = maybeApplySizeMultiplier(height, sizeMultiplier);</div><div class="line"></div><div class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">      logV(&quot;finished setup for calling load in &quot; + LogTime.getElapsedMillis(startTime));</div><div class="line">    &#125;</div><div class="line">    loadStatus = engine.load(</div><div class="line">        glideContext,</div><div class="line">        model,</div><div class="line">        requestOptions.getSignature(),</div><div class="line">        this.width,</div><div class="line">        this.height,</div><div class="line">        requestOptions.getResourceClass(),</div><div class="line">        transcodeClass,</div><div class="line">        priority,</div><div class="line">        requestOptions.getDiskCacheStrategy(),</div><div class="line">        requestOptions.getTransformations(),</div><div class="line">        requestOptions.isTransformationRequired(),</div><div class="line">        requestOptions.getOptions(),</div><div class="line">        requestOptions.isMemoryCacheable(),</div><div class="line">        requestOptions.getUseUnlimitedSourceGeneratorsPool(),</div><div class="line">        this);</div><div class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">      logV(&quot;finished onSizeReady in &quot; + LogTime.getElapsedMillis(startTime));</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>那么这个engine从哪里来的呢？它在glide初始化的时候，就创建了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (engine == null) &#123;</div><div class="line">      engine = new Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>包括参数内存缓存和磁盘缓存。然后我们看一下load具体实现，这里代码比较多，所以我就挑了几个重要的看了一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">//给每次加载资源创建一个key，作为唯一的标识。</div><div class="line">    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</div><div class="line">        resourceClass, transcodeClass, options);</div><div class="line"></div><div class="line">//通过key load缓存资源，这是一级内存缓存，是从内存缓存中直接拿出来的</div><div class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</div><div class="line">    if (cached != null) &#123;</div><div class="line">         cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</div><div class="line">      if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">        logWithTimeAndKey(&quot;Loaded resource from cache&quot;, startTime, key);</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//这里是二级内存缓存，使用Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt;保存起来的</div><div class="line">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</div><div class="line">    if (active != null) &#123;</div><div class="line">      cb.onResourceReady(active, DataSource.MEMORY_CACHE);</div><div class="line">      if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">        logWithTimeAndKey(&quot;Loaded resource from active resources&quot;, startTime, key);</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//根据key获取缓存的任务</div><div class="line">    EngineJob&lt;?&gt; current = jobs.get(key);</div><div class="line">    if (current != null) &#123;</div><div class="line">      current.addCallback(cb);</div><div class="line">      if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">        logWithTimeAndKey(&quot;Added to existing load&quot;, startTime, key);</div><div class="line">      &#125;</div><div class="line">      return new LoadStatus(cb, current);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//创建任务</div><div class="line">    EngineJob&lt;R&gt; engineJob = engineJobFactory.build(key, isMemoryCacheable,</div><div class="line">        useUnlimitedSourceExecutorPool);</div><div class="line">    DecodeJob&lt;R&gt; decodeJob = decodeJobFactory.build(</div><div class="line">        glideContext,</div><div class="line">        model,</div><div class="line">        key,</div><div class="line">        signature,</div><div class="line">        width,</div><div class="line">        height,</div><div class="line">        resourceClass,</div><div class="line">        transcodeClass,</div><div class="line">        priority,</div><div class="line">        diskCacheStrategy,</div><div class="line">        transformations,</div><div class="line">        isTransformationRequired,</div><div class="line">        options,</div><div class="line">        engineJob);</div><div class="line">    jobs.put(key, engineJob);</div><div class="line">    engineJob.addCallback(cb);</div><div class="line">    //放入线程池，执行</div><div class="line">    engineJob.start(decodeJob);</div><div class="line"></div><div class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">      logWithTimeAndKey(&quot;Started new load&quot;, startTime, key);</div><div class="line">    &#125;</div><div class="line">    return new LoadStatus(cb, engineJob);</div></pre></td></tr></table></figure>
<p>还有一个问题，这个二级缓存，是谁放入二级内存中呢，我们看一下上面一级缓存的loadFromCache方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private EngineResource&lt;?&gt; loadFromCache(Key key, boolean isMemoryCacheable) &#123;</div><div class="line">   if (!isMemoryCacheable) &#123;</div><div class="line">     return null;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</div><div class="line">   if (cached != null) &#123;</div><div class="line">     cached.acquire();</div><div class="line">     activeResources.put(key, new ResourceWeakReference(key, cached, getReferenceQueue()));</div><div class="line">   &#125;</div><div class="line">   return cached;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这里把带有key的缓存存到activeResources中，二级缓存中loadFromActiveResources函数，也是从activeResources中拿到资源，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private EngineResource&lt;?&gt; loadFromActiveResources(Key key, boolean isMemoryCacheable) &#123;</div><div class="line">  if (!isMemoryCacheable) &#123;</div><div class="line">    return null;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  EngineResource&lt;?&gt; active = null;</div><div class="line">  //从activeResources中拿到key的cache</div><div class="line">  WeakReference&lt;EngineResource&lt;?&gt;&gt; activeRef = activeResources.get(key);</div><div class="line">  if (activeRef != null) &#123;</div><div class="line">    active = activeRef.get();</div><div class="line">    if (active != null) &#123;</div><div class="line">      active.acquire();</div><div class="line">    &#125; else &#123;</div><div class="line">      activeResources.remove(key);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return active;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除此之外呢?<br>1、一级内存缓存，glide中默认的就是我们常用的LruResourceCache。<br>2、我们说glide是加载imageview，我们从哪里知道的呢，还记得使用的时候into()函数中我们传入的是imageview，而我们源码中的target就是我们传进来的imageview。在track函数中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void track(Target&lt;?&gt; target) &#123;</div><div class="line">   targets.add(target);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>我们将target也就是我们的imageview加入到缓存中去了。<br>3、为何要两级内存缓存（loadFromActiveResources）。从资料上看猜测可能是一级缓存采用LRU算法进行缓存，不一定每个都能缓存到，添加二级缓存 可以保证每个都能缓存到；<br>4、EngineJob和DecodeJob各自职责：EngineJob充当了管理和调度者，主要负责加载和各类回调通知；DecodeJob是真正干活的劳动者，这个类实现了Runnable接口。</p>
<p>那我们来看一下真正线程(DecodeJob)里面是怎么执行的？<br>我怕大家忘了engine.load的代码，所以我先把使用EngineJob和DecodeJob的代码贴在下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//创建任务</div><div class="line">    EngineJob&lt;R&gt; engineJob = engineJobFactory.build(key, isMemoryCacheable,</div><div class="line">        useUnlimitedSourceExecutorPool);</div><div class="line">    DecodeJob&lt;R&gt; decodeJob = decodeJobFactory.build(</div><div class="line">        glideContext,</div><div class="line">        model,</div><div class="line">        key,</div><div class="line">        signature,</div><div class="line">        width,</div><div class="line">        height,</div><div class="line">        resourceClass,</div><div class="line">        transcodeClass,</div><div class="line">        priority,</div><div class="line">        diskCacheStrategy,</div><div class="line">        transformations,</div><div class="line">        isTransformationRequired,</div><div class="line">        options,</div><div class="line">        engineJob);</div><div class="line">    jobs.put(key, engineJob);</div><div class="line">    engineJob.addCallback(cb);</div><div class="line">    //放入线程池，执行</div><div class="line">    engineJob.start(decodeJob);</div><div class="line"></div><div class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">      logWithTimeAndKey(&quot;Started new load&quot;, startTime, key);</div><div class="line">    &#125;</div><div class="line">    return new LoadStatus(cb, engineJob);</div></pre></td></tr></table></figure></p>
<p>然后我们在继续看一下DecodeJob是如何执行的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">  public void run() &#123;</div><div class="line">    // This should be much more fine grained, but since Java&apos;s thread pool implementation silently</div><div class="line">    // swallows all otherwise fatal exceptions, this will at least make it obvious to developers</div><div class="line">    // that something is failing.</div><div class="line">    try &#123;</div><div class="line">      if (isCancelled) &#123;</div><div class="line">        notifyFailed();</div><div class="line">        return;</div><div class="line">      &#125;</div><div class="line">      runWrapped();</div><div class="line">    &#125; catch (RuntimeException e) &#123;</div><div class="line">      if (Log.isLoggable(TAG, Log.DEBUG)) &#123;</div><div class="line">        Log.d(TAG, &quot;DecodeJob threw unexpectedly&quot;</div><div class="line">            + &quot;, isCancelled: &quot; + isCancelled</div><div class="line">            + &quot;, stage: &quot; + stage, e);</div><div class="line">      &#125;</div><div class="line">      // When we&apos;re encoding we&apos;ve already notified our callback and it isn&apos;t safe to do so again.</div><div class="line">      if (stage != Stage.ENCODE) &#123;</div><div class="line">        notifyFailed();</div><div class="line">      &#125;</div><div class="line">      if (!isCancelled) &#123;</div><div class="line">        throw e;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>然后在看里面的runWrapped函数，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private void runWrapped() &#123;</div><div class="line">   switch (runReason) &#123;</div><div class="line">    case INITIALIZE:</div><div class="line">    //初始化，获取下一个阶段的状态</div><div class="line">      stage = getNextStage(Stage.INITIALIZE);</div><div class="line">      currentGenerator = getNextGenerator();</div><div class="line">      //运行</div><div class="line">      runGenerators();</div><div class="line">      break;</div><div class="line">    case SWITCH_TO_SOURCE_SERVICE:</div><div class="line">      runGenerators();</div><div class="line">      break;</div><div class="line">    case DECODE_DATA:</div><div class="line">      decodeFromRetrievedData();</div><div class="line">      break;</div><div class="line">    default:</div><div class="line">      throw new IllegalStateException(&quot;Unrecognized run reason: &quot; + runReason);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先看getNextStage方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 这里的阶段策略首先是从resource中寻找，然后再是data，，再是source</div><div class="line">private Stage getNextStage(Stage current) &#123;</div><div class="line">    switch (current) &#123;</div><div class="line">      case INITIALIZE:</div><div class="line">      // 根据定义的缓存策略来回去下一个状态</div><div class="line">	  // 缓存策略来之于RequestBuilder的requestOptions域</div><div class="line">	  // 如果你有自定义的策略，可以调用RequestBuilder.apply方法即可</div><div class="line">	  // 详细的可用缓存策略请参看DiskCacheStrategy.java</div><div class="line">        return diskCacheStrategy.decodeCachedResource()</div><div class="line">            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);</div><div class="line">      case RESOURCE_CACHE:</div><div class="line">        return diskCacheStrategy.decodeCachedData()</div><div class="line">            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);</div><div class="line">      case DATA_CACHE:</div><div class="line">        return Stage.SOURCE;</div><div class="line">      case SOURCE:</div><div class="line">      case FINISHED:</div><div class="line">        return Stage.FINISHED;</div><div class="line">      default:</div><div class="line">        throw new IllegalArgumentException(&quot;Unrecognized stage: &quot; + current);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>再看getNextGenerator函数，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 根据Stage找到数据抓取生成器。</div><div class="line">private DataFetcherGenerator getNextGenerator() &#123;</div><div class="line">    switch (stage) &#123;</div><div class="line">      case RESOURCE_CACHE:</div><div class="line">       // 产生含有降低采样/转换资源数据缓存文件的DataFetcher。</div><div class="line">        return new ResourceCacheGenerator(decodeHelper, this);</div><div class="line">      case DATA_CACHE:</div><div class="line">      // 产生包含原始未修改的源数据缓存文件的DataFetcher。</div><div class="line">        return new DataCacheGenerator(decodeHelper, this);</div><div class="line">      case SOURCE:</div><div class="line">      // 生成使用注册的ModelLoader和加载时提供的Model获取源数据规定的DataFetcher。</div><div class="line">      // 根据不同的磁盘缓存策略，源数据可首先被写入到磁盘，然后从缓存文件中加载，而不是直接返回。</div><div class="line">        return new SourceGenerator(decodeHelper, this);</div><div class="line">      case FINISHED:</div><div class="line">        return null;</div><div class="line">      default:</div><div class="line">        throw new IllegalStateException(&quot;Unrecognized stage: &quot; + stage);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>经过上面的流程，最后就是发起实际请求的地方了，SourceGenerator.startNext()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">  public boolean startNext() &#123;</div><div class="line">    if (dataToCache != null) &#123;</div><div class="line">      Object data = dataToCache;</div><div class="line">      dataToCache = null;</div><div class="line">      cacheData(data);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (sourceCacheGenerator != null &amp;&amp; sourceCacheGenerator.startNext()) &#123;</div><div class="line">      return true;</div><div class="line">    &#125;</div><div class="line">    sourceCacheGenerator = null;</div><div class="line"></div><div class="line">    loadData = null;</div><div class="line">    boolean started = false;</div><div class="line">    while (!started &amp;&amp; hasNextModelLoader()) &#123;</div><div class="line">      loadData = helper.getLoadData().get(loadDataListIndex++);</div><div class="line">      if (loadData != null</div><div class="line">          &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</div><div class="line">          || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</div><div class="line">        started = true;</div><div class="line">        loadData.fetcher.loadData(helper.getPriority(), this);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    return started;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里的Model必须是实现了GlideModule接口的，fetcher是实现了DataFetcher接口。有兴趣同学可以继续看一下integration中的okhttp和volley工程。Glide主要采用了这两种网络libray来下载图片。</p>
<p>数据下载完成后缓存处理SourceGenerator.onDataReady</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"> public void onDataReady(Object data) &#123;</div><div class="line">   DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();</div><div class="line">   if (data != null &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;</div><div class="line">     dataToCache = data;</div><div class="line">     // We might be being called back on someone else&apos;s thread. Before doing anything, we should</div><div class="line">     // reschedule to get back onto Glide&apos;s thread.</div><div class="line">     cb.reschedule();</div><div class="line">   &#125; else &#123;</div><div class="line">     cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher,</div><div class="line">         loadData.fetcher.getDataSource(), originalKey);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这里将下载的data存到磁盘cache中，但是咋就一句dataToCache = data，其实是在cb.reschedule()，cb就是decodeJob。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void reschedule() &#123;</div><div class="line">    runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;</div><div class="line">    callback.reschedule(this);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里又有一个Callback，继续追踪，这里的Callback接口是定义在DecodeJob内的，而实现是在外部的Engine中（这里会用线程池重新启动当前job，那为什么要这样做呢？源码中的解释是为了不同线程的切换，因为下载都是借用第三方网络库，而实际的编解码是在Glide自定义的线程池中进行的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void reschedule(DecodeJob&lt;?&gt; job) &#123;</div><div class="line">  if (isCancelled) &#123;</div><div class="line">    MAIN_THREAD_HANDLER.obtainMessage(MSG_CANCELLED, this).sendToTarget();</div><div class="line">  &#125; else &#123;</div><div class="line">    sourceExecutor.execute(job);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来继续DecodeJob.runWrapped()方法。这个时候的runReason是SWITCH_TO_SOURCE_SERVICE，因此直接执行runGenerators()，这里继续执行SourceGenerator.startNext()方法，值得注意的dataToCache域，因为上一次执行的时候是下载，因此再次执行的时候内存缓存已经存在，因此直接缓存数据cacheData(data)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">private void cacheData(Object dataToCache) &#123;</div><div class="line">  long startTime = LogTime.getLogTime();</div><div class="line">  try &#123;</div><div class="line">    Encoder&lt;Object&gt; encoder = helper.getSourceEncoder(dataToCache);</div><div class="line">    DataCacheWriter&lt;Object&gt; writer =</div><div class="line">        new DataCacheWriter&lt;&gt;(encoder, dataToCache, helper.getOptions());</div><div class="line">    originalKey = new DataCacheKey(loadData.sourceKey, helper.getSignature());</div><div class="line">    helper.getDiskCache().put(originalKey, writer);</div><div class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">      Log.v(TAG, &quot;Finished encoding source to cache&quot;</div><div class="line">          + &quot;, key: &quot; + originalKey</div><div class="line">          + &quot;, data: &quot; + dataToCache</div><div class="line">          + &quot;, encoder: &quot; + encoder</div><div class="line">          + &quot;, duration: &quot; + LogTime.getElapsedMillis(startTime));</div><div class="line">    &#125;</div><div class="line">  &#125; finally &#123;</div><div class="line">    loadData.fetcher.cleanup();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  sourceCacheGenerator =</div><div class="line">      new DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在会到SourceGenerator.startNext()方法，这个时候已经有了sourceCacheGenerator，那么直接执行DataCacheGenerator.startNext()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"> public boolean startNext() &#123;</div><div class="line">   while (modelLoaders == null || !hasNextModelLoader()) &#123;</div><div class="line">     sourceIdIndex++;</div><div class="line">     if (sourceIdIndex &gt;= cacheKeys.size()) &#123;</div><div class="line">       return false;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     Key sourceId = cacheKeys.get(sourceIdIndex);</div><div class="line">     Key originalKey = new DataCacheKey(sourceId, helper.getSignature());</div><div class="line">     cacheFile = helper.getDiskCache().get(originalKey);</div><div class="line">     if (cacheFile != null) &#123;</div><div class="line">       this.sourceKey = sourceId;</div><div class="line">       modelLoaders = helper.getModelLoaders(cacheFile);</div><div class="line">       modelLoaderIndex = 0;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   loadData = null;</div><div class="line">   boolean started = false;</div><div class="line">   // 这里会通过model寻找注册过的ModelLoader</div><div class="line">   while (!started &amp;&amp; hasNextModelLoader()) &#123;</div><div class="line">     ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++);</div><div class="line">     loadData =</div><div class="line">         modelLoader.buildLoadData(cacheFile, helper.getWidth(), helper.getHeight(),</div><div class="line">             helper.getOptions());</div><div class="line">             // 通过FileLoader继续加载数据</div><div class="line">     if (loadData != null &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) &#123;</div><div class="line">       started = true;</div><div class="line">       loadData.fetcher.loadData(helper.getPriority(), this);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   return started;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这里的ModelLoader跟之前提到过的Register的模块加载器（ModelLoader）对应是modelLoaderRegistry域，具体执行的操作是Registry.getModelLoaders(…)方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public &lt;Model&gt; List&lt;ModelLoader&lt;Model, ?&gt;&gt; getModelLoaders(Model model) &#123;</div><div class="line">   List&lt;ModelLoader&lt;Model, ?&gt;&gt; result = modelLoaderRegistry.getModelLoaders(model);</div><div class="line">   if (result.isEmpty()) &#123;</div><div class="line">     throw new NoModelLoaderAvailableException(model);</div><div class="line">   &#125;</div><div class="line">   return result;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>继续回到DataCacheGenerator.startNext()方法，找到了ModelLoader，然后跟踪到的是FileLoader类(FileFetcher.loadData(…)方法)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public void loadData(Priority priority, DataCallback&lt;? super Data&gt; callback) &#123;</div><div class="line">	// 读取文件数据</div><div class="line">     try &#123;</div><div class="line">       data = opener.open(file);</div><div class="line">     &#125; catch (FileNotFoundException e) &#123;</div><div class="line">       if (Log.isLoggable(TAG, Log.DEBUG)) &#123;</div><div class="line">         Log.d(TAG, &quot;Failed to open file&quot;, e);</div><div class="line">       &#125;</div><div class="line">	//失败</div><div class="line">       callback.onLoadFailed(e);</div><div class="line">       return;</div><div class="line">     &#125;</div><div class="line">  // 成功</div><div class="line">     callback.onDataReady(data);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><strong>装载流程</strong></p>
<p>代码太多，实在有点绕晕了，所以就将一位大神的博客里面装载流程粘了过来。<br>主要线路如下：<br>–&gt;DataCacheGenerator.onDataReady<br>  –&gt;SourceGenerator.onDataFetcherReady<br>    –&gt;DecodeJob.onDataFetcherReady<br>    –&gt;DecodeJob.decodeFromRetrievedData<br>    –&gt;DecodeJob.notifyEncodeAndRelease<br>    –&gt;DecodeJob.notifyComplete<br>      –&gt;EngineJob.onResourceReady</p>
<p>需要说明的就是在EngineJob中有一个Handler叫MAIN_THREAD_HANDLER。为了实现在主UI中装载资源的作用，ok继续上边的流程：</p>
<p>–&gt;EngineJob.handleResultOnMainThread<br>  –&gt;SingleRequest.onResourceReady<br>    –&gt;ImageViewTarget.onResourceReady<br>    –&gt;ImageViewTarget.setResource<br>      –&gt;ImageView.setImageDrawable/ImageView.setImageBitmap</p>
<p>数据的装载过程中有一个很重要的步骤就是decode，这个操作发生在DecodeJob.decodeFromRetrievedData的时候，继续看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">private void decodeFromRetrievedData() &#123;</div><div class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">      logWithTimeAndKey(&quot;Retrieved data&quot;, startFetchTime,</div><div class="line">          &quot;data: &quot; + currentData</div><div class="line">          + &quot;, cache key: &quot; + currentSourceKey</div><div class="line">          + &quot;, fetcher: &quot; + currentFetcher);</div><div class="line">    &#125;</div><div class="line">    Resource&lt;R&gt; resource = null;</div><div class="line">    try &#123;</div><div class="line">      resource = decodeFromData(currentFetcher, currentData, currentDataSource);</div><div class="line">    &#125; catch (GlideException e) &#123;</div><div class="line">      e.setLoggingDetails(currentAttemptingKey, currentDataSource);</div><div class="line">      exceptions.add(e);</div><div class="line">    &#125;</div><div class="line">    if (resource != null) &#123;</div><div class="line">      notifyEncodeAndRelease(resource, currentDataSource);</div><div class="line">    &#125; else &#123;</div><div class="line">      runGenerators();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这中间发生了很多转换主要流程：</p>
<p>–&gt;DecodeJob.decodeFromData<br>–&gt;DecodeJob.decodeFromFetcher<br>–&gt;DecodeJob.runLoadPath<br>  –&gt;LoadPath.load<br>  –&gt;LoadPath.loadWithExceptionList<br>  –&gt;LoadPath.decode<br>  –&gt;LoadPath.decodeResource<br>  –&gt;LoadPath.decodeResourceWithList<br>    –&gt;ResourceDecoder.handles<br>    –&gt;ResourceDecoder.decode</p>
<p>这里讲到了decode，那么encode发生在什么时候呢？直接通过Encoder接口调用发现，在数据缓存的时候才会触发编码。具体调用在DiskLruCacheWrapper和DataCacheWriter中。一些值得参考的写法例如BitmapEncoder对Bitmap的压缩处理。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p><strong>总结，glide库很大，自己在看源码的时候，也参考了别人对glide的理解，将glide的大概流程的主要源码看了一下，其中可能会有很多理解不对或者不足的地方，希望大家能给指出来。</strong><br>下面是是一位大神看完glide之后的结束语，个人觉得还是很不错的。</p>
<p>1、总体来说代码写的挺漂亮的，单从使用者角度来说入手是比较容易的。<br>2、源码使用了大量的工厂方法来创建对象，就像String.valueof(…)方法一样，这也体现编码的优雅。<br>3、不过想要对这个库进行改造，可能并非易事，笔者在跟踪代码的过程中发现很多地方有Callback这样的接口，来来回回查找几次很容易就晕头转向了。。。<br>另外一个感觉难受的地方就是构造方法带入参数太多，就拿SingleRequest来说就是12个构造参数。<br>4、单例的使用感觉还是有些模糊，就比如GlideContext，有些时候通过Glide.get(context).getGlideContext()获取，而有些类中采用构造传入。个人觉得既然让Glide作为单例，那么还这样传入参数是不是有点多余？代码的编写都是可以折中考虑，不过如果整个项目拟定好了一个规则的话，我想最好还是遵循它。另外再吐槽一下单例，很多开发人员喜欢用单例，如果你是有代码洁癖的开发者，那么你肯定很讨厌这样，单例很容易造成代码的散落和结构不清晰。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/08/Glide深入浅出(二)/" data-id="ciw6kx7nx000500ugcgb4owy1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/glide/">glide</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Glide深入浅出(一)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/07/Glide深入浅出(一)/" class="article-date">
  <time datetime="2016-09-07T08:36:18.000Z" itemprop="datePublished">2016-09-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/07/Glide深入浅出(一)/">Glide深入浅出（一）——Glide vs Picasso</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前，Google推出了一个图片加载库Glide。因为我们之前使用的ImageLoader比较多，所以现在我就准备研究一下Glide这个框架。<br>首先，我要先说的是好，Glide这个库看起来跟Picasso这个库非常的相似，感觉glide应该是Picasso库的翻版。那么第一章，我们就PK一下glide和Picasso。</p>
<p><strong>导入库</strong></p>
<p>Picasso</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile &apos;com.squareup.picasso:picasso:2.5.1&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>glide</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile &apos;com.github.bumptech.glide:glide:3.5.2&apos;</div><div class="line">    compile &apos;com.android.support:support-v4:22.0.0&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>glide需要android support library v4，所以在你的项目中，不要忘记导入support-v4包。</p>
<p><strong>基本使用</strong><br>说他们俩很像，其实就是在使用上两者很像。</p>
<p>Picasso</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Picasso.with(context)</div><div class="line">    .load(&quot;http://inthecheesefactory.com/uploads/source/glidepicasso/cover.jpg&quot;)</div><div class="line">    .into(ivImg);</div></pre></td></tr></table></figure>
<p>glide</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Glide.with(context)</div><div class="line">    .load(&quot;http://inthecheesefactory.com/uploads/source/glidepicasso/cover.jpg&quot;)</div><div class="line">    .into(ivImg);</div></pre></td></tr></table></figure>
<p>虽然两者使用起来看着很像，但是glide设计的更加好，因为glide.with(context)中，可以支持activity和fragment，context会自动识别转化的。我们可以看一下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static RequestManager with(Context context) &#123;</div><div class="line">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</div><div class="line">    return retriever.get(context);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static RequestManager with(Activity activity) &#123;</div><div class="line">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</div><div class="line">    return retriever.get(activity);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">   public static RequestManager with(FragmentActivity activity) &#123;</div><div class="line">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</div><div class="line">    return retriever.get(activity);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>可以看到这里，不仅可以传context还可以传activity和fragment对象，这样我们使用起来就不用转化context了。当然在在传入context的函数中，glide还做了识别处理，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public RequestManager get(Context context) &#123;</div><div class="line">   if (context == null) &#123;</div><div class="line">     throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);</div><div class="line">   &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123;</div><div class="line">     if (context instanceof FragmentActivity) &#123;</div><div class="line">       return get((FragmentActivity) context);</div><div class="line">     &#125; else if (context instanceof Activity) &#123;</div><div class="line">       return get((Activity) context);</div><div class="line">     &#125; else if (context instanceof ContextWrapper) &#123;</div><div class="line">       return get(((ContextWrapper) context).getBaseContext());</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   return getApplicationManager(context);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>又把属于fragment和activity的context又识别了一波。</p>
<p>传入activity或fragment的好处：图片加载将会跟着activity和fragment的生命周期活动，activity或fragment生命周期onPause的时候，图片就会pause加载，onResume的时候，图片就会onResume加载。所以推荐，不要传入context到glide，尽量传activity或者fragment。</p>
<p><strong>默认bitmap格式是 RGB_565</strong></p>
<p>glide默认的bitmap格式是RGB_565，这个比Picasso只用的ARGB_8888少用一半的内存，所以glide图片展示没有Picasso清晰，下面是两个内存消耗比较：</p>
<p><img src="http://img.blog.csdn.net/20160907154723240" alt="这里写图片描述"></p>
<p>但是如果你需要高质量的图片，你需要把bitmap格式转化为ARGB_8888，你需要实现一个接口GlideModule，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class GlideConfiguration implements GlideModule &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void applyOptions(Context context, GlideBuilder builder) &#123;</div><div class="line">      builder.setDecodeFormat(DecodeFormat.PREFER_ARGB_8888);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void registerComponents(Context context, Glide glide) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在AndroidManifest定义一个meta-data，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;meta-data android:name=&quot;com.inthecheesefactory.lab.glidepicasso.GlideConfiguration&quot;</div><div class="line">            android:value=&quot;GlideModule&quot;/&gt;</div></pre></td></tr></table></figure>
<p>这样的话，glide图片看起来好多了。<br>变成ARGB_8888后，glide内存消耗也变大了，但是仍然比Picasso小。<br>这是为啥咧？<br>假设我们要加载一个1920x1080的图片，Picasso会将整个图片加载下来，而glide加载的是imageview大小（假设我们imageview大小是768x432）</p>
<p><strong>Disk缓存</strong><br>当我的imageview有不同的size，而且同时加载一张图片，Picasso硬盘缓存只缓存这一张图片，但是glide机制不一样，因为glide加载的imageview，所以你如果有不同size的imageview，虽然是同一张图片，但是glide还是会将这些不同size的imageview都缓存下来。<br>当然你可以通过下面的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Glide.with(this)</div><div class="line">             .load(&quot;http://nuuneoi.com/uploads/source/playstore/cover.jpg&quot;)</div><div class="line">             .diskCacheStrategy(DiskCacheStrategy.ALL)</div><div class="line">             .into(ivImgGlide);</div></pre></td></tr></table></figure>
<p>这样的话，缓存全大小的图片，然后在resize和cache。<br>glide默认这种加载方式，也有好处，就是加载速度快，Picasso缓存全尺寸图片，加载到imageview还需要测量imageview的大小进行裁剪，而glide加载的图片不需要测量大小，所以glide加载速度很快。</p>
<p><strong>glide能做，Picasso不能做的</strong><br>glide可以load gif图片，而Picasso做不到。</p>
<p><strong>库大小</strong></p>
<p><img src="http://img.blog.csdn.net/20160907163104426" alt="这里写图片描述"></p>
<p>哈哈，glide大小能顶Picasso的四倍了，方法数也多了很多。</p>
<p><img src="http://img.blog.csdn.net/20160907163206801" alt="这里写图片描述"></p>
<p><strong>总结</strong><br>glide和Picasso pk结果：<br>glide优点：加载速度快，可以处理gif、video等图片流。<br>Picasso优点：体积小，图片质量高。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/07/Glide深入浅出(一)/" data-id="ciw6kx7nv000400ughvo011pl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/glide/">glide</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/picasso/">picasso</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android WebView深入浅出" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/05/Android WebView深入浅出/" class="article-date">
  <time datetime="2016-09-05T12:27:18.000Z" itemprop="datePublished">2016-09-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/05/Android WebView深入浅出/">Android WebView深入浅出</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>一、基本使用</strong><br>首先在layout中一个简单的空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;WebView</div><div class="line">        android:id=&quot;@+id/webView1&quot;</div><div class="line">        android:layout_width=&quot;fill_parent&quot;</div><div class="line">        android:layout_height=&quot;fill_parent&quot;</div><div class="line">        android:layout_marginTop=&quot;10dp&quot; /&gt;</div></pre></td></tr></table></figure>
<p>同时，因为要访问网络，所以在manifest中必须要加网络访问的权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</div></pre></td></tr></table></figure>
<p>在activity中即可获得webview的引用，同时load一个网址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">webview = (WebView) findViewById(R.id.webView1);</div><div class="line">webview.loadUrl(&quot;http://www.baidu.com/&quot;);</div></pre></td></tr></table></figure>
<p>这个时候，启动应用后，自动打开了系统内置的浏览器，所以要为这个webview设置webviewclient，并重写方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">webview.setWebViewClient(new WebViewClient()&#123;</div><div class="line">            @Override</div><div class="line">            public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</div><div class="line">                view.loadUrl(url);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>若自己定义一个页面加载进度的progressBar，通过以下方式来获取webview内加载进度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">webview.setWebChromeClient(new WebChromeClient()&#123;</div><div class="line">            @Override</div><div class="line">            public void onProgressChanged(WebView view, int newProgress) &#123;</div><div class="line">                //get the newProgress and refresh progress bar</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>当然每个页面都有一个标题，js会设置标题，那我们原生的native如何添加title呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">webview.setWebChromeClient(new WebChromeClient()&#123;</div><div class="line">            @Override</div><div class="line">            public void onReceivedTitle(WebView view, String title) &#123;</div><div class="line">                titleview.setText(title);//a textview</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p><strong>二、通过webview下载文件</strong><br>通常webview渲染的界面中含有可以下载文件的链接，点击该链接后，应该开始执行下载的操作并保存文件到本地中。webview来下载页面中的文件通常有两种方式：</p>
<ol>
<li>自己通过一个线程写java io的代码来下载和保存文件（可控性好）</li>
<li>调用系统download的模块（代码简单）</li>
</ol>
<p>方法一：<br>先写一个download线程类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">public class HttpThread extends Thread &#123;</div><div class="line"></div><div class="line"></div><div class="line">    private String mUrl;</div><div class="line"></div><div class="line">    public HttpThread(String mUrl) &#123;</div><div class="line">        this.mUrl = mUrl;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        URL url;</div><div class="line">        try &#123;</div><div class="line">            url = new URL(mUrl);</div><div class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">            conn.setDoInput(true);</div><div class="line">            conn.setDoOutput(true);</div><div class="line">            InputStream in = conn.getInputStream();</div><div class="line">            </div><div class="line">            File downloadFile;</div><div class="line">            File sdFile;</div><div class="line">            FileOutputStream out = null;</div><div class="line">            if(Environment.getExternalStorageState().equals(Environment.MEDIA_UNMOUNTED))&#123;</div><div class="line">                downloadFile = Environment.getExternalStorageDirectory();</div><div class="line">                sdFile = new File(downloadFile, &quot;test.file&quot;);</div><div class="line">                out = new FileOutputStream(sdFile);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            //buffer 4k</div><div class="line">            byte[] buffer = new byte[1024 * 4];</div><div class="line">            int len = 0;</div><div class="line">            while((len = in.read(buffer)) != -1)&#123;</div><div class="line">                if(out != null)</div><div class="line">                    out.write(buffer, 0, len);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            //close resource</div><div class="line">            if(out != null)</div><div class="line">                out.close();</div><div class="line">            </div><div class="line">            if(in != null)&#123;</div><div class="line">                in.close();</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            </div><div class="line">            </div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            // TODO Auto-generated catch block</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后要实现一个DownloadLisener接口，这个接口中实现OnDownloadStart方法，用户点击下载链接的时候，这个回调方法会调用传进来的URL，然后将URL放到我们上面写的HttpThread进行下载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class MyDownloadListenter implements DownloadListener&#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onDownloadStart(String url, String userAgent,</div><div class="line">                String contentDisposition, String mimetype, long contentLength) &#123;</div><div class="line">            System.out.println(&quot;url ==== &gt;&quot; + url);</div><div class="line">            new HttpThread(url).start();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">//给webview加入监听</div><div class="line">webview.setDownloadListener(new MyDownloadListenter());</div></pre></td></tr></table></figure>
<p>方法二：<br>直接发送一个action_view的intent就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class MyDownloadListenter implements DownloadListener&#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onDownloadStart(String url, String userAgent,</div><div class="line">                String contentDisposition, String mimetype, long contentLength) &#123;</div><div class="line">            System.out.println(&quot;url ==== &gt;&quot; + url);</div><div class="line">            //new HttpThread(url).start();</div><div class="line">            </div><div class="line">            Uri uri = Uri.parse(url);</div><div class="line">            Intent intent = new Intent(Intent.ACTION_VIEW, uri);</div><div class="line">            startActivity(intent);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>错误处理</strong><br>当我们使用浏览器的时候，通常因为加载的页面的服务器的各种原因导致各种出错的情况，最平常的比如404错误，通常情况下浏览器会提示一个错误提示页面。事实上这个错误提示页面是浏览器在加载了本地的一个页面，用来提示用户目前已经出错了。</p>
<p>但是当我们的app里面使用webview控件的时候遇到了诸如404这类的错误的时候，若也显示浏览器里面的那种错误提示页面就显得很丑陋了，那么这个时候我们的app就需要加载一个本地的错误提示页面，即webview如何加载一个本地的页面。</p>
<ol>
<li><p>首先我们需要些一个html文件，比如error_handle.html，这个文件里面就是当出错的时候需要展示给用户看的一个错误提示页面，尽量做的精美一些。然后将该文件放置到代码根目录的assets文件夹下。</p>
</li>
<li><p>随后我们需要复写WebViewClient的onRecievedError方法，该方法传回了错误码，根据错误类型可以进行不同的错误分类处理</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">webview.setWebViewClient(new WebViewClient()&#123;</div><div class="line">       </div><div class="line">            @Override</div><div class="line">            public void onReceivedError(WebView view, int errorCode,</div><div class="line">                    String description, String failingUrl) &#123;</div><div class="line">                switch(errorCode)</div><div class="line">                &#123;</div><div class="line">                case HttpStatus.SC_NOT_FOUND:</div><div class="line">                    view.loadUrl(&quot;file:///android_assets/error_handle.html&quot;);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>其实，当出错的时候，我们可以选择隐藏掉webview，而显示native的错误处理控件，这个时候只需要在onReceivedError里面显示出错误处理的native控件同时隐藏掉webview即可。</p>
<p><strong>四、webview与js交互</strong><br>1、webview调用js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mWebView.loadUrl(&quot;javascript:do()&quot;);</div></pre></td></tr></table></figure>
<p>比如这个中webview调用的是do方法，js在html大概如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">    &lt;script language=&quot;javascript&quot;&gt;</div><div class="line">        /* This function is invoked by the webview*/</div><div class="line">        function do() &#123;</div><div class="line">            alert(&quot;1&quot;);</div><div class="line">        &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;a onClick=&quot;window.demo.clickOnAndroid()&quot;&gt;&lt;div style=&quot;width:80px;</div><div class="line">            margin:0px auto;</div><div class="line">            padding:10px;</div><div class="line">            text-align:center;</div><div class="line">            border:2px solid #111111;&quot; &gt;</div><div class="line">                &lt;img id=&quot;droid&quot; src=&quot;xx.png&quot;/&gt;&lt;br&gt;</div><div class="line">                Click me!</div><div class="line">        &lt;/div&gt;&lt;/a&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>2、js调用webview<br>假设我们某些方法要给js调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class DemoJavaScriptInterface &#123;</div><div class="line"></div><div class="line">        DemoJavaScriptInterface() &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * This is not called on the UI thread. Post a runnable to invoke</div><div class="line">         * loadUrl on the UI thread.</div><div class="line">         */</div><div class="line">        public void clickOnAndroid() &#123;</div><div class="line">            mHandler.post(new Runnable() &#123;</div><div class="line">                public void run() &#123;</div><div class="line">                    //TODO</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>首先给webview设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mWebview.setJavaScriptEnabled(true);</div></pre></td></tr></table></figure>
<p>然后将本地类映射出去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mWebView.addJavascriptInterface(new DemoJavaScriptInterface(), &quot;demo&quot;);</div></pre></td></tr></table></figure>
<p>这样就可以在js中直接调用本地java的方法。</p>
<p><strong>五、webview和js互相调用混淆</strong><br>若webview中的js调用了本地的方法，正常情况下发布的debug包js调用的时候是没有问题的，但是通常发布商业版本的apk都是要经过混淆的步骤，这个时候会发现之前调用正常的js却无法正常调用本地方法了。</p>
<p>这是因为混淆的时候已经把本地的代码的引用给打乱了，导致js中的代码找不到本地的方法的地址。</p>
<p>解决这个问题很简单，即在proguard.cfg文件中加上一些代码，声明本地中被js调用的代码不被混淆。下面举例说明：</p>
<p>第四部分中被js调用的那个类DemoJavaScriptInterface的包名为com.test.webview，那么就要在proguard.cfg文件中加入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-keep public class com.test.webview.DemoJavaScriptInterface&#123;</div><div class="line">    public &lt;methods&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>若是内部类，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-keep public class com.test.webview.DemoJavaScriptInterface$InnerClass&#123;</div><div class="line">    public &lt;methods&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>若是android比较新，需要添加如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-keepattributes *Annotation*  </div><div class="line">-keepattributes *JavascriptInterface*</div></pre></td></tr></table></figure>
<p><strong>六、webview同步cookies</strong><br>cookies是服务器用来保存每个客户的常用信息的，下次客户进入一个诸如登陆的页面时服务器会检测cookie信息，如果通过则直接进入登陆后的页面。</p>
<p>在webview中，如果之前已经登陆过了，那么下次再进入同样的登陆界面时，若需要再次登陆的话，一定会很恼人，所以这里提供一个webview同步cookies的方法。</p>
<p>1.首先，我们假设某个网站的登陆界面需要提供两个参数，一个是name，一个是pwd，那么要是对这个页面进行登陆，那么必须给与这两个信息。我们假设服务器已经注册了name为jason，pwd为123456这个账号。</p>
<p>2.下面，写一个Thread用来将name和pwd自动的登入，在服务器返回的response中获得cookie信息，稍后对这个cookie进行保存，这里先给出这个Thread的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class HttpCookie extends Thread &#123;</div><div class="line"></div><div class="line">    private Handler mHandler;</div><div class="line"></div><div class="line">    public HttpCookie(Handler mHandler) &#123;</div><div class="line">        this.mHandler = mHandler;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        HttpClient client = new DefaultHttpClient();</div><div class="line">        HttpPost post = new HttpPost(&quot;&quot;);//this place should add the login address</div><div class="line">        </div><div class="line">        List&lt;NameValuePair&gt; list = new ArrayList&lt;NameValuePair&gt;();</div><div class="line">        list.add(new BasicNameValuePair(&quot;name&quot;, &quot;jason&quot;));</div><div class="line">        list.add(new BasicNameValuePair(&quot;pwd&quot;, &quot;123456&quot;));</div><div class="line">        </div><div class="line">        try &#123;</div><div class="line">            post.setEntity(new UrlEncodedFormEntity(list));</div><div class="line">            HttpResponse reponse = client.execute(post);</div><div class="line">            if(reponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK)&#123;</div><div class="line">                AbstractHttpClient absClient = (AbstractHttpClient) client;</div><div class="line">                List&lt;Cookie&gt; cookies = absClient.getCookieStore().getCookies();</div><div class="line">                </div><div class="line">                for(Cookie cookie:cookies)&#123;</div><div class="line">                    if(cookie != null)&#123;</div><div class="line">                        //TODO</div><div class="line">                        //this place would get the cookies</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</div><div class="line">            // TODO Auto-generated catch block</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (ClientProtocolException e) &#123;</div><div class="line">            // TODO Auto-generated catch block</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            // TODO Auto-generated catch block</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于这是一个子线程，所以需要在主线程中创建并执行。</p>
<p>同时，因为其实子线程，那么里面必须含有一个handler的元素，用来当成功获取cookie后通知主线程进行同步和保存。初始化这个子线程的时候需要将主线程上的handler给传过来，随后在以上代码的TODO中发送消息，让主线程记录cookie，发送的这个消息需要将cookie信息包含进去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if(cookie != null)&#123;</div><div class="line">    //TODO</div><div class="line">    //this place would get the cookies</div><div class="line">    Message msg = new Message();</div><div class="line">    msg.obj = cookie;</div><div class="line">    if(mHandler != null)&#123;</div><div class="line">        mHandler.sendMessage(msg);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>随后在主线程中（webview加载登陆界面前），在handler中将会获取到cookie信息，下面将对该cookie进行保存和同步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private Handler mHandler = new Handler()&#123;</div><div class="line">       public void handleMessage(android.os.Message msg) </div><div class="line">       &#123;</div><div class="line">       CookieSyncManager.createInstance(MainActivity.this);</div><div class="line">           CookieManager cookieMgr = CookieManager.getInstance();</div><div class="line">           cookieMgr.setAcceptCookie(true);</div><div class="line">           cookieMgr.setCookie(&quot;&quot;, msg.obj.toString());// this place should add the login host address(not the login index address)</div><div class="line">           CookieSyncManager.getInstance().sync();</div><div class="line">           </div><div class="line">           webview.loadUrl(&quot;&quot;);// login index address</div><div class="line">       &#125;;</div><div class="line">   &#125;;</div></pre></td></tr></table></figure>
<p>这个时候发现webview加载的login index页面中可以自动的登陆了并显示登陆后的界面。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/05/Android WebView深入浅出/" data-id="ciw6kx7n9000000ughuox5f22" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dp/">dp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webview/">webview</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/布局/">布局</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深入浅出Android Support Annotations" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/25/深入浅出Android Support Annotations/" class="article-date">
  <time datetime="2016-08-25T04:03:18.000Z" itemprop="datePublished">2016-08-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/25/深入浅出Android Support Annotations/">深入浅出Android Support Annotations</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>自己在项目中使用一些第三方的框架的时候，经常使用各种注解，使用起来十分方便，所以就简单了解了一下注解的使用。</p>
<p>首先将注解添加到我们工程中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile &apos;com.android.support:support-annotations:20.0.0&apos;</div></pre></td></tr></table></figure>
<p>有三种类型的注解可供我们使用：<br>Nullness注解；<br>资源类型注解；<br>IntDef和StringDef注解；</p>
<p>这几种类型的使用，我就通过一些示例代码来介绍一下。</p>
<p><strong>Nullness注解</strong></p>
<p>使用@NonNull注解修饰的参数不能为null。在下面的代码例子中，我们有一个取值为null的name变量，它被作为参数传递给sayHello函数，而该函数要求这个参数是非null的String类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends ActionBarActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        String corn = null;</div><div class="line">        sayCorns(corn);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void sayCorns(@NonNull String s) &#123;</div><div class="line">        Toast.makeText(this, &quot;Hello &quot; + s, Toast.LENGTH_LONG).show();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数hello中的参数使用NonNull来修饰，所以参数不能是null，而我们把name设置为null，所以IDE会以警告的方式提示我们。</p>
<p><strong>资源类型注解</strong></p>
<p>我们之前有没有遇到一种比较尴尬的问题，同样是资源文件，我们有时候将错误的资源类型id传给函数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends ActionBarActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        sayCorns(R.style.AppTheme);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void sayCorns(int id) &#123;</div><div class="line">        Toast.makeText(this, &quot;Hello &quot; + getString(id), Toast.LENGTH_LONG).show();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本来是想获得string资源的东西，结果你传了一个style里面的id给她，这样是不是很尴尬。不过没关系，资源类型注解帮我们解决这种问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends ActionBarActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        sayCorns(R.style.AppTheme);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    void sayCorns(@StringRes int id) &#123;</div><div class="line">        Toast.makeText(this, &quot;Hello &quot; + getString(id), Toast.LENGTH_LONG).show();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>加了一个StringRes注解之后，当传入一个资源文件id给他的时候，IDE就会有警告提示。</p>
<p><strong>IntDef和StringDef注解</strong></p>
<p>很多时候，我们使用整型常量代替枚举类型（性能考虑），例如我们有一个IceCreamFlavourManager类，它具有三种模式的操作：VANILLA，CHOCOLATE和STRAWBERRY。我们可以定义一个名为@Flavour的新注解，并使用@IntDef指定它可以接受的值类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class IceCreamFlavourManager &#123;</div><div class="line"></div><div class="line">    private int flavour;</div><div class="line"></div><div class="line">    public static final int VANILLA = 0;</div><div class="line">    public static final int CHOCOLATE = 1;</div><div class="line">    public static final int STRAWBERRY = 2;</div><div class="line"></div><div class="line">    @IntDef(&#123;VANILLA, CHOCOLATE, STRAWBERRY&#125;)</div><div class="line">    public @interface Corns &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Corns</div><div class="line">    public int getFlavour() &#123;</div><div class="line">        return flavour;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setFlavour(@Corns int flavour) &#123;</div><div class="line">        this.flavour = flavour;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们在使用setFlavour的时候，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IceCreamFlavourManager ice=new IceCreamFlavourManager();</div><div class="line">ice.setFlavour(4);</div></pre></td></tr></table></figure>
<p>因为4不属于@IntDef中任一一个类型，所以IDE会报错。</p>
<p>@StringDef用法和@IntDef基本差不多，只不过是针对String类型而已。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/25/深入浅出Android Support Annotations/" data-id="ciw6kx7oo000w00ug2ah03k4g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/annotations/">annotations</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/support/">support</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-View Touch事件处理机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/View Touch事件处理机制/" class="article-date">
  <time datetime="2016-07-06T07:41:18.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/View Touch事件处理机制/">View Touch事件处理机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>1、MotionEvent介绍</strong></p>
<p>系统有一个线程在循环收集屏幕硬件信息，当用户触摸屏幕的时候 ，这个线程就会把从设备信息收集到的信息封装成一个MotionEvent，然后把对象放到一个消息队列中。<br>系统另外一个线程循环读取消息队列中的MotionEvent，然后派发给当前活动的activity。<br>这个时间，系统收集信息是有时间间隔的，这个取决于硬件设备，目前手机应该在20毫秒左右。<br>MotionEvent事件我就不作具体介绍了，ACTION_DOWN、ACTION_MOVE、ACTION_UP、ACTION_CANCEL 。</p>
<p><strong>2、view touch事件处理</strong></p>
<p>我们都知道android里面view是一层层的，当有touch时间传过来的时候，也会从父层到子层传递。这里就需要onTouchEvent和onInterceptTouchEvent来控制touch事件是否往子层传，dispatchTouchEvent是用于touch事件分发，决定事件是否由onInterceptTouchEvent来拦截处理。<br>我们看一下ViewGroup中的dispatchTouchEvent源码（由于代码太多太繁琐，所以我就挑着看一下重要代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if (!canceled &amp;&amp; !intercepted) &#123;</div><div class="line">	for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</div><div class="line">	…</div><div class="line">	if (dispatchTransformedTouchEvent(ev, cancelChild,</div><div class="line">                                target.child, target.pointerIdBits)) &#123;</div><div class="line">                     handled = true;</div><div class="line">             &#125;</div><div class="line">	…</div><div class="line">	return handled;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是事件处理流程的关键循环，但是for循环之前有个判断条件，就是这个intercepted，然后我们看一下intercepted如何被定义的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                    || mFirstTouchTarget != null) &#123;</div><div class="line">                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</div><div class="line">                if (!disallowIntercept) &#123;</div><div class="line">                    intercepted = onInterceptTouchEvent(ev);</div><div class="line">                    ev.setAction(action); // restore action in case it was changed</div><div class="line">                &#125; else &#123;</div><div class="line">                    intercepted = false;</div><div class="line">                &#125;</div></pre></td></tr></table></figure>
<p>由此可以看出，dispatch其实就是否则touch事件分发，决定事件是否由onInterceptTouchEvent来拦截处理。返回super.dispatchTouchEvent时，由onInterceptTouchEvent来决定事件的流向。返回false时，会继续分发事件，自己内部只处理了ACTION_DOWN。返回true时，不会继续分发事件，自己内部处理了所有事件（ACTION_DOWN,ACTION_MOVE,ACTION_UP）</p>
<p><strong>3、onInterceptTouchEvent（事件拦截）</strong><br>拦截事件，用来决定事件是否传向子View<br>返回true时，拦截后交给自己的onTouchEvent处理<br>返回false时，拦截后交给子View来处理</p>
<p><strong>4、onTouchEvent（事件处理）：事件最终到达这个方法</strong><br>返回true时，内部处理所有的事件，换句话说，后续事件将继续传递给该view的onTouchEvent()处理<br>返回false时，事件会向上传递，由onToucEvent来接受，如果最上面View中的onTouchEvent也返回false的话，那么事件就会消失</p>
<p><strong>5、验证</strong><br>ViewA.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class ViewA extends FrameLayout &#123;</div><div class="line"></div><div class="line">    public ViewA(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        Log.d(Constant.LOGCAT, &quot;Group1 onInterceptTouchEvent触发事件：&quot;+Constant.getActionTAG(ev.getAction()));</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        Log.d(Constant.LOGCAT, &quot;Group1 onTouchEvent触发事件：&quot;+Constant.getActionTAG(event.getAction()));</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ViewB.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class ViewB extends FrameLayout&#123;</div><div class="line"></div><div class="line">    public ViewB(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        Log.d(Constant.LOGCAT, &quot;Group2 onInterceptTouchEvent触发事件：&quot;+ Constant.getActionTAG(ev.getAction()));</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        Log.d(Constant.LOGCAT, &quot;Group2 onTouchEvent触发事件：&quot;+Constant.getActionTAG(event.getAction()));</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>MyTextView.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class MyTextView extends TextView&#123;</div><div class="line"></div><div class="line">    public MyTextView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        this.setGravity(Gravity.CENTER);</div><div class="line">        this.setText(&quot;点击我！&quot;);</div><div class="line">        // TODO Auto-generated constructor stub</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        Log.d(Constant.LOGCAT, &quot;MyTextView onTouchEvent触发事件：&quot;+ Constant.getActionTAG(event.getAction()));</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Constant.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Constant &#123;</div><div class="line">    public static final String LOGCAT = &quot;logcat&quot;;</div><div class="line"></div><div class="line">    public static String getActionTAG(int action) &#123;</div><div class="line">        switch (action) &#123;</div><div class="line">            case 0:</div><div class="line">                return &quot;ACTION_DOWN&quot;;</div><div class="line">            case 1:</div><div class="line">                return &quot;ACTION_UP&quot;;</div><div class="line">            case 2:</div><div class="line">                return &quot;ACTION_MOVE&quot;;</div><div class="line">            default:</div><div class="line">                return &quot;NULL&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>MainActivity.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    ViewA viewA;</div><div class="line">    ViewB viewB;</div><div class="line">    MyTextView myTextView;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        viewA = new ViewA(this);</div><div class="line">        viewB = new ViewB(this);</div><div class="line">        myTextView = new MyTextView(this);</div><div class="line">        viewB.addView(myTextView, new ActionBar.LayoutParams(ActionBar.LayoutParams.FILL_PARENT,</div><div class="line">                ActionBar.LayoutParams.FILL_PARENT));</div><div class="line">        viewA.addView(viewB, new ActionBar.LayoutParams(ActionBar.LayoutParams.FILL_PARENT,</div><div class="line">                ActionBar.LayoutParams.FILL_PARENT));</div><div class="line">        setContentView(viewA);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后更改onTouch和InterceptTouch返回值就可以看到log啦，具体大家去试一下就可以啦！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/06/View Touch事件处理机制/" data-id="ciw6kx7nz000600ug111589dj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/touch/">touch</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/view/">view</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Weapp/">Weapp</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/annotations/">annotations</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/app/">app</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/camera/">camera</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dp/">dp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/glide/">glide</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gridview/">gridview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/inflater/">inflater</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/layout/">layout</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/native/">native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/picasso/">picasso</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/support/">support</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/touch/">touch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/view/">view</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/viewgroup/">viewgroup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/volley/">volley</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/weChat/">weChat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webview/">webview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存/">内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数/">函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图片/">图片</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/对象/">对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/布局/">布局</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/支付宝/">支付宝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/框架/">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程/">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/缓存/">缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自定义/">自定义</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计/">设计</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/annotations/" style="font-size: 10px;">annotations</a> <a href="/tags/app/" style="font-size: 10px;">app</a> <a href="/tags/camera/" style="font-size: 12.5px;">camera</a> <a href="/tags/dp/" style="font-size: 10px;">dp</a> <a href="/tags/glide/" style="font-size: 12.5px;">glide</a> <a href="/tags/gridview/" style="font-size: 10px;">gridview</a> <a href="/tags/inflater/" style="font-size: 10px;">inflater</a> <a href="/tags/layout/" style="font-size: 10px;">layout</a> <a href="/tags/native/" style="font-size: 12.5px;">native</a> <a href="/tags/picasso/" style="font-size: 10px;">picasso</a> <a href="/tags/support/" style="font-size: 10px;">support</a> <a href="/tags/touch/" style="font-size: 12.5px;">touch</a> <a href="/tags/view/" style="font-size: 12.5px;">view</a> <a href="/tags/viewgroup/" style="font-size: 10px;">viewgroup</a> <a href="/tags/volley/" style="font-size: 15px;">volley</a> <a href="/tags/weChat/" style="font-size: 10px;">weChat</a> <a href="/tags/webview/" style="font-size: 10px;">webview</a> <a href="/tags/内存/" style="font-size: 10px;">内存</a> <a href="/tags/函数/" style="font-size: 10px;">函数</a> <a href="/tags/图片/" style="font-size: 10px;">图片</a> <a href="/tags/对象/" style="font-size: 10px;">对象</a> <a href="/tags/布局/" style="font-size: 12.5px;">布局</a> <a href="/tags/支付宝/" style="font-size: 10px;">支付宝</a> <a href="/tags/框架/" style="font-size: 10px;">框架</a> <a href="/tags/源码/" style="font-size: 17.5px;">源码</a> <a href="/tags/线程/" style="font-size: 10px;">线程</a> <a href="/tags/缓存/" style="font-size: 12.5px;">缓存</a> <a href="/tags/网络/" style="font-size: 10px;">网络</a> <a href="/tags/自定义/" style="font-size: 10px;">自定义</a> <a href="/tags/设计/" style="font-size: 10px;">设计</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/12/01/基于ReactNative和Realm的开源项目/">自定义相机遇到的坑总结</a>
          </li>
        
          <li>
            <a href="/2016/12/01/自定义相机踩过的坑/">自定义相机踩过的坑</a>
          </li>
        
          <li>
            <a href="/2016/09/26/微信小程序学习资料汇总/">微信小程序学习资料汇总</a>
          </li>
        
          <li>
            <a href="/2016/09/26/一个自定义的GridLayout/">一个自定义的GridLayout</a>
          </li>
        
          <li>
            <a href="/2016/09/13/LayoutInflater原理解析/">深入了解View（一）——LayoutInflater原理分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Volley源码解析(三)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/04/Volley源码解析(三)/" class="article-date">
  <time datetime="2016-07-04T09:30:18.000Z" itemprop="datePublished">2016-07-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/04/Volley源码解析(三)/">Volley源码解析（三）——图片加载</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上一章详细介绍了volley网络请求的流程，这一章将会介绍一下volley图片加载部分源码分析。<br>Volley还可以进行图片的加载和缓存，可以利用ImageRequest对象简单、方便地进行网络图片的获取。ImageLoader用于获取或缓存图片。NetworkImageView是Volley提供的一个自定义View，可直接设置网络图片。</p>
<p><strong>1、使用ImageRequest进行网络图片获取</strong><br>使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ImageRequest request = new ImageRequest(url, new Response.Listener&lt;Bitmap&gt;() &#123;    </div><div class="line">    @Override    </div><div class="line">    public void onResponse(Bitmap response) &#123;  </div><div class="line">        //给imageView设置图片      </div><div class="line">        myImageView.setImageBitmap(response);    </div><div class="line">    &#125;</div><div class="line">&#125;, 0, 0, ImageView.ScaleType.CENTER, Bitmap.Config.RGB_565, new Response.ErrorListener() &#123;    </div><div class="line">    @Override    </div><div class="line">    public void onErrorResponse(VolleyError error) &#123; </div><div class="line">          //设置一张错误的图片，临时用ic_launcher代替          </div><div class="line">	               myImageView.setImageResource(R.drawable.ic_launcher);    </div><div class="line">   &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>然后再将ImageRequest加入到RequestQueue队列中，进行网络请求，传入一些参数：<br>String ： 要获取的图片地址<br>Response.Listener<bitmap> ： 获取图片成功的回调<br>int： maxWidth，获取图片的最大宽度，会自动进行压缩或拉伸，设置为0，即获取原图<br>int ：maxHeight，同上<br>ScaleType ：显示的类型，居中，平铺等<br>Config：图片类型，如：Bitmap.Config.RGB_565<br>Response.ErrorListener： 获取图片失败的回调</bitmap></p>
<p><strong>2、使用ImageLoader缓存网络图片</strong><br>使用imageloader需要以下三步骤，我们从使用方法来看一下源码实现。</p>
<p>2.1 实例化ImageLoader</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ImageLoader loader = new ImageLoader(requestQueue, new BitmapCache());</div></pre></td></tr></table></figure>
<p>requestQueue是前面讲过的请求队列，BitmapCache是一个接口，需要我们自定义imageCache对象。我们可以使用LruCache作为图片缓存对象，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class BitmapCache implements ImageLoader.ImageCache &#123;    </div><div class="line">  private LruCache&lt;String, Bitmap&gt; lruCache ;    </div><div class="line">  private int max = 10*1024*1024;    </div><div class="line"></div><div class="line">   public BitmapCache()&#123;       </div><div class="line">     lruCache = new LruCache&lt;String, Bitmap&gt;(max)&#123;            </div><div class="line">      @Override            </div><div class="line">      protected int sizeOf(String key, Bitmap value) &#123;                </div><div class="line">         return value.getRowBytes()*value.getHeight();            </div><div class="line">      &#125;        </div><div class="line">     &#125;;    </div><div class="line">   &#125;   </div><div class="line">   @Override    </div><div class="line">   public Bitmap getBitmap(String url) &#123;        </div><div class="line">      return lruCache.get(url);    </div><div class="line">   &#125;    </div><div class="line">   @Override    </div><div class="line">   public void putBitmap(String url, Bitmap bitmap) &#123;          </div><div class="line">      lruCache.put(url, bitmap);    </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.2 设置监听器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ImageLoader.ImageListener listener = </div><div class="line">         ImageLoader.getImageListener(myImageView, R.drawable.ic_launcher, R.drawable.ic_launcher);</div></pre></td></tr></table></figure>
<p>我们看一下ImageLoader.java中的ImageListener函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public static ImageListener getImageListener(final ImageView view,</div><div class="line">           final int defaultImageResId, final int errorImageResId) &#123;</div><div class="line">       return new ImageListener() &#123;</div><div class="line">           @Override</div><div class="line">           public void onErrorResponse(VolleyError error) &#123;</div><div class="line">               if (errorImageResId != 0) &#123;</div><div class="line">                   view.setImageResource(errorImageResId);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onResponse(ImageContainer response, boolean isImmediate) &#123;</div><div class="line">               if (response.getBitmap() != null) &#123;</div><div class="line">                   view.setImageBitmap(response.getBitmap());</div><div class="line">               &#125; else if (defaultImageResId != 0) &#123;</div><div class="line">                   view.setImageResource(defaultImageResId);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>就是返回一个ImageListener，里面定义了ImageListener接口。</p>
<p>2.3 获取图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">loader.get(url, listener);</div></pre></td></tr></table></figure>
<p>我们看一下源码imageloader中的get函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">throwIfNotOnMainThread();</div><div class="line"></div><div class="line">   final String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight, scaleType);</div><div class="line">   Bitmap cachedBitmap = mCache.getBitmap(cacheKey);</div><div class="line">   if (cachedBitmap != null) &#123;</div><div class="line">           ImageContainer container = new ImageContainer(cachedBitmap, requestUrl, null, null);</div><div class="line">            imageListener.onResponse(container, true);</div><div class="line">            return container;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">       ImageContainer imageContainer =</div><div class="line">                new ImageContainer(null, requestUrl, cacheKey, imageListener);</div><div class="line">       imageListener.onResponse(imageContainer, true);</div><div class="line">       BatchedImageRequest request = mInFlightRequests.get(cacheKey);</div><div class="line">        if (request != null) &#123;</div><div class="line">            request.addContainer(imageContainer);</div><div class="line">            return imageContainer;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Request&lt;Bitmap&gt; newRequest = makeImageRequest(requestUrl, maxWidth, maxHeight, scaleType,</div><div class="line">                cacheKey);</div><div class="line"></div><div class="line">        mRequestQueue.add(newRequest);</div><div class="line">        mInFlightRequests.put(cacheKey,</div><div class="line">                new BatchedImageRequest(newRequest, imageContainer));</div><div class="line">        return imageContainer;</div></pre></td></tr></table></figure>
<p>我们将这些源码分解开来看。</p>
<p>2.3.1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">final String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight, scaleType);</div><div class="line">  Bitmap cachedBitmap = mCache.getBitmap(cacheKey);</div><div class="line">  if (cachedBitmap != null) &#123;</div><div class="line">          ImageContainer container = new ImageContainer(cachedBitmap, requestUrl, null, null);</div><div class="line">           imageListener.onResponse(container, true);</div><div class="line">           return container;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p>这段代码，我们先看一下缓存中有没有我们自定义的getBitmap图片，就是我们上面自定义的BitmapCache，上面我使用的是LruCache。如果缓存中有我们要网络加载的图片的话，即cachedBitmap != null，我们就可以回调，显示出来啦。</p>
<p>2.3.2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BatchedImageRequest request = mInFlightRequests.get(cacheKey);</div><div class="line">       if (request != null) &#123;</div><div class="line">           request.addContainer(imageContainer);</div><div class="line">           return imageContainer;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p>判断一下请求是否在请求队列中，如果在就直接return。</p>
<p>2.3.3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Request&lt;Bitmap&gt; newRequest = makeImageRequest(requestUrl, maxWidth, maxHeight, scaleType,  cacheKey);</div><div class="line"></div><div class="line">        mRequestQueue.add(newRequest);</div><div class="line">        mInFlightRequests.put(cacheKey,</div><div class="line">                new BatchedImageRequest(newRequest, imageContainer));</div><div class="line">        return imageContainer;</div></pre></td></tr></table></figure>
<p>如果不在队列和缓存中，就要就要request加入到网络请求中，关键函数就是makeImageRequest，我们看一下源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">return new ImageRequest(requestUrl, new Listener&lt;Bitmap&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onResponse(Bitmap response) &#123;</div><div class="line">                onGetImageSuccess(cacheKey, response);</div><div class="line">            &#125;</div><div class="line">        &#125;, maxWidth, maxHeight, scaleType, Config.RGB_565, new ErrorListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onErrorResponse(VolleyError error) &#123;</div><div class="line">                onGetImageError(cacheKey, error);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>这就是网络请求，返回数据处理，看一下onGetImageSuccess函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 放到缓存中</div><div class="line">      mCache.putBitmap(cacheKey, response);</div><div class="line"></div><div class="line">      // 从请求队列中remove掉</div><div class="line">      BatchedImageRequest request = mInFlightRequests.remove(cacheKey);</div><div class="line"></div><div class="line">      if (request != null) &#123;</div><div class="line">           request.mResponseBitmap = response;</div><div class="line">           batchResponse(cacheKey, request);</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>我们在看一下batchResponse函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">mBatchedResponses.put(cacheKey, request);</div><div class="line">   // If we don&apos;t already have a batch delivery runnable in flight, make a new one.</div><div class="line">  // Note that this will be used to deliver responses to all callers in mBatchedResponses.</div><div class="line">        if (mRunnable == null) &#123;</div><div class="line">            mRunnable = new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    for (BatchedImageRequest bir : mBatchedResponses.values()) &#123;</div><div class="line">                        for (ImageContainer container : bir.mContainers) &#123;</div><div class="line">                            // If one of the callers in the batched request canceled the request</div><div class="line">                            // after the response was received but before it was delivered,</div><div class="line">                            // skip them.</div><div class="line">                            if (container.mListener == null) &#123;</div><div class="line">                                continue;</div><div class="line">                            &#125;</div><div class="line">                            if (bir.getError() == null) &#123;</div><div class="line">                                container.mBitmap = bir.mResponseBitmap;</div><div class="line">                                container.mListener.onResponse(container, false);</div><div class="line">                            &#125; else &#123;</div><div class="line">                                container.mListener.onErrorResponse(bir.getError());</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    mBatchedResponses.clear();</div><div class="line">                    mRunnable = null;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;;</div><div class="line">            // Post the runnable.</div><div class="line">            mHandler.postDelayed(mRunnable, mBatchResponseDelayMs);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>请求队列循环，当container.mListener ！= null并且bir.getError() == null，就可以回调container.mListener.onResponse(container, false)函数，然后这个线程每隔100ms执行一次。</p>
<p>volley图片加载部分到这里就结束了，但我还是没有找到图片网络请求具体部分在哪里，这是我对volley网络图片加载部分的理解，有些地方的理解有问题，如果有不对的地方，希望各位大神指点。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/04/Volley源码解析(三)/" data-id="ciw6kt7bl0009pmugh0nlz8zf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/volley/">volley</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/图片/">图片</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/对象/">对象</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/缓存/">缓存</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Volley源码解析(二)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/02/Volley源码解析(二)/" class="article-date">
  <time datetime="2016-07-02T10:05:18.000Z" itemprop="datePublished">2016-07-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/02/Volley源码解析(二)/">Volley源码解析(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上面一个章节，从volley的主要使用流程来大概分析了一下代码，这一章将详细的网络请求流程从源码角度分析一波。</p>
<p>前面一章讲了NetworkDispatcher.java，这个线程主要任务就是网络请求和处理，其中run()函数中执行网络请求的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NetworkResponse networkResponse = mNetwork.performRequest(request);</div></pre></td></tr></table></figure>
<p>performRequest函数的实现，我们看一下BasicNetwork中performRequest函数（其中BasicNetwork.java是Network的实现类），代码很多，我截取了一部分核心的代码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;();</div><div class="line">addCacheHeaders(headers, request.getCacheEntry());</div><div class="line">//网络请求</div><div class="line">httpResponse = mHttpStack.performRequest(request, headers);</div><div class="line">StatusLine statusLine = httpResponse.getStatusLine();</div><div class="line">int statusCode = statusLine.getStatusCode();</div><div class="line"></div><div class="line">responseHeaders = convertHeaders(httpResponse.getAllHeaders());</div><div class="line">if (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</div><div class="line">      Entry entry = request.getCacheEntry();</div><div class="line">      if (entry == null) &#123;</div><div class="line">             return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null,</div><div class="line">                                responseHeaders, true,</div><div class="line">                                SystemClock.elapsedRealtime() - requestStart);</div><div class="line">       &#125;</div><div class="line">       entry.responseHeaders.putAll(responseHeaders);</div><div class="line">       return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,</div><div class="line">                            entry.responseHeaders, true,</div><div class="line">                            SystemClock.elapsedRealtime() - requestStart);</div><div class="line">       &#125;</div><div class="line">       if (httpResponse.getEntity() != null) &#123;</div><div class="line">            responseContents = entityToBytes(httpResponse.getEntity());</div><div class="line">       &#125;else &#123;</div><div class="line">             responseContents = new byte[0];</div><div class="line">       &#125;</div><div class="line">       long requestLifetime = SystemClock.elapsedRealtime() - requestStart;</div><div class="line">       logSlowRequests(requestLifetime, request, responseContents, statusLine);</div><div class="line">       if (statusCode &lt; 200 || statusCode &gt; 299) &#123;</div><div class="line">            throw new IOException();</div><div class="line">       &#125;</div><div class="line">return new NetworkResponse(statusCode, responseContents, responseHeaders,   false,SystemClock.elapsedRealtime() - requestStart);</div></pre></td></tr></table></figure>
<p>代码比较多，前一部分代码就是做网络请求，后面一部分是对网络请求返回的response进行处理（包括head和entity）。网络请求的代码就一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">httpResponse = mHttpStack.performRequest(request, headers);</div></pre></td></tr></table></figure>
<p>mHttpStack就是一个接口，它有两个实现类，就是我们上一章介绍的RequestQueue，当API&gt;=9的时候，使用HurlStack，反之，使用HttpClientStack。这两个stack就是HttpStack的具体实现类。</p>
<p><strong>1、我们先看一下HurlStack实现performRequest方法。</strong></p>
<p>1.1 首先获取request中的url。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String url = request.getUrl();</div><div class="line">URL parsedUrl = new URL(url);</div></pre></td></tr></table></figure>
<p>1.2 打开http连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HttpURLConnection connection = openConnection(parsedUrl, request);</div></pre></td></tr></table></figure>
<p>openConnection实现方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">HttpURLConnection connection = createConnection(url);</div><div class="line">int timeoutMs = request.getTimeoutMs();</div><div class="line">connection.setConnectTimeout(timeoutMs);</div><div class="line">connection.setReadTimeout(timeoutMs);</div><div class="line">connection.setUseCaches(false);</div><div class="line">connection.setDoInput(true);</div></pre></td></tr></table></figure>
<p>如代码所示，openConnection方法使用系统的HttpURLConnection类，设置timeout，缓存等参数，然后return。</p>
<p>1.3 打开网络连接了，我们继续看performRequest方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setConnectionParametersForRequest(connection, request);</div></pre></td></tr></table></figure>
<p>如函数名字意思一样，就是为request设置一些parameters，我们看一下这个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">                .......</div><div class="line">                </div><div class="line">case Method.GET:</div><div class="line">     connection.setRequestMethod(&quot;GET&quot;);</div><div class="line">     break;</div><div class="line">case Method.DELETE:</div><div class="line">     connection.setRequestMethod(&quot;DELETE&quot;);</div><div class="line">     break;</div><div class="line">case Method.POST:</div><div class="line">     connection.setRequestMethod(&quot;POST&quot;);</div><div class="line">     addBodyIfExists(connection, request);</div><div class="line">     break;</div><div class="line">     </div><div class="line">               ........</div></pre></td></tr></table></figure>
<p>就是设置一些请求的方法。</p>
<p>1.4 返回code，报错处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int responseCode = connection.getResponseCode();</div><div class="line">if (responseCode == -1) &#123;</div><div class="line">  throw new IOException(&quot;Could not retrieve response code from HttpUrlConnection.&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1.5 最后返回response</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return response;</div></pre></td></tr></table></figure>
<p><strong>2、我们再看一下HttpClientStack的实现方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HttpUriRequest httpRequest = createHttpRequest(request, additionalHeaders);</div><div class="line">addHeaders(httpRequest, additionalHeaders);</div><div class="line">addHeaders(httpRequest, request.getHeaders());</div><div class="line">onPrepareRequest(httpRequest);</div><div class="line">HttpParams httpParams = httpRequest.getParams();</div><div class="line">int timeoutMs = request.getTimeoutMs();</div><div class="line">HttpConnectionParams.setConnectionTimeout(httpParams, 5000);</div><div class="line">HttpConnectionParams.setSoTimeout(httpParams, timeoutMs);</div><div class="line">return mClient.execute(httpRequest);</div></pre></td></tr></table></figure>
<p>这里创建的网络请求是使用HttpClient中HttpUriRequest包来做网络请求，下面类似于HurlStack，用来添加参数。</p>
<p>好啦，介绍好了两个实现类（HttpClientStack和HurlStack）中performRequest的实现方法，我们在继续BasicNetwork的performRequest方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">responseHeaders = convertHeaders(httpResponse.getAllHeaders());</div><div class="line">if (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</div><div class="line">Entry entry = request.getCacheEntry();</div><div class="line">if (entry == null) &#123;</div><div class="line">   return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null,</div><div class="line">                                responseHeaders, true,</div><div class="line">                                SystemClock.elapsedRealtime() - requestStart);</div><div class="line">&#125;</div><div class="line">                   </div><div class="line">entry.responseHeaders.putAll(responseHeaders);</div><div class="line">return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,</div><div class="line">                            entry.responseHeaders, true,</div><div class="line">                            SystemClock.elapsedRealtime() - requestStart);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把request的head和Entry进行包装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if (httpResponse.getEntity() != null) &#123;</div><div class="line">    responseContents = entityToBytes(httpResponse.getEntity());</div><div class="line">&#125; else &#123;</div><div class="line">    responseContents = new byte[0];</div><div class="line">&#125;</div><div class="line">                </div><div class="line">long requestLifetime = SystemClock.elapsedRealtime() - requestStart;</div><div class="line">logSlowRequests(requestLifetime, request, responseContents, statusLine);</div><div class="line">return new NetworkResponse(statusCode, responseContents, responseHeaders,   false,SystemClock.elapsedRealtime() - requestStart);</div></pre></td></tr></table></figure>
<p>最后return新的response。</p>
<p>现在网络请求已经完成，下面就应该开一个线程，把这个网络请求跑起来啦。我们再回到networkDispatcher.java中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mDelivery.postResponse(request, response);</div></pre></td></tr></table></figure>
<p>我们看一下ResponseDelivery实现类ExecutorDelivery中的postResponse方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">request.markDelivered();</div><div class="line">request.addMarker(&quot;post-response&quot;);</div><div class="line">mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));</div></pre></td></tr></table></figure>
<p>这个方法，把request网络请求放到ResponseDeliveryRunnable中。</p>
<p>这大概就是我理解的volley网络请求的详细流程，如果有哪里不对的地方，希望大神们指点一二。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/02/Volley源码解析(二)/" data-id="ciw6kt7bs000fpmug6t5ayu4t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/volley/">volley</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/函数/">函数</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程/">线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Volley源码解析(一)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/27/Volley源码解析(一)/" class="article-date">
  <time datetime="2016-06-27T11:30:18.000Z" itemprop="datePublished">2016-06-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/27/Volley源码解析(一)/">Volley源码解析(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这个章节，我先介绍volley功能介绍、总体设计、类设计、主要流程的源码解析，其他方法，例如图片加载、HurlStack、HttpClientStack、performRequest等，我会在后面进行介绍。</p>
<p><strong>1、功能介绍</strong><br>1.1 volley是异步网络请求框架和图片加载器。<br>1.2 优点<br>       1、请求队列和请求优先级。<br>       2、请求Cache和内存管理。<br>       3、扩展性强，大多是基于接口的设计，可配置型强。<br>       4、可以取消请求。<br>       5、提供简单的图片加载工具。</p>
<p><strong>2、总体设计</strong><br>2.1 总体设计图如下：<br><img src="http://img.blog.csdn.net/20160627191325478" alt="这里写图片描述"><br>通过Dispatch Thread不断从RequestQueue中获取请求，根据是否已缓存调用Cache或者Network这两类数据获取接口其中之一，从内存缓存或者是服务器中获取数据，然后交给ResponseDelivery去做结果分发以及回调处理。</p>
<p>2.2 核心功能点概念<br>volley使用，通过newRequestQueue()函数新建并启动一个请求队列RequestQueue，然后不断向这个队列中添加Request就可以了。<br>Volley：对外暴露的API，通过newRequestQueue()函数新建并启动一个请求队列RequestQueue。<br>Request：表示一个请求的抽象类。StringRequest、JsonRequest、ImageRequest都是它的子类，表示某种类型的请求。<br>RequestQueue：请求队列，里面包含一个CacheDispatcher（缓存请求的线程）、多个NetworkDispatcher（处理网络请求的线程），start函数启动CacheDispatcher和NetworkDispatcher。<br>CacheDispatcher：用于处理缓存请求。不断从缓存请求队列中获取请求处理，队列为空的时候则等待，请求处理结束后将结果传递给ResponseDelivery去执行后续处理。当结果没有被缓存过、缓存失效等情况下，这个请求都要重新进入NetworkDispatcher去调度处理。<br>NetworkDispatcher：用于处理网络请求。不断从网络请求队列中获取请求处理，队列为空的时候则等待，请求结果传递给ResponseDelivery去执行后续处理，并判断结果是否要进行缓存。<br>ResponseDelivery：返回结果分发接口。<br>HttpStack：处理Http请求，返回请求结果。目前Volley中有基于HttpURLConnection的HurlStack和基于Apache HttpClient的HttpClientStack。<br>Network：调用HttpStack处理请求，将结果转化为可以被ResponseDelivery处理的NetworkResponse。<br>Cache：缓存请求结果，默认使用sdcard的DiskBasedCache。NetworkDispatcher得到结果后判断是否需要存在Cache，CacheDispatcher会从Cache中获取缓存结果。<br>2.3 流程图<br><img src="http://img.blog.csdn.net/20160627191431652" alt="这里写图片描述"></p>
<p>3、类设计图<br><img src="http://img.blog.csdn.net/20160627191513387" alt="这里写图片描述"><br>红色部分，围绕RequestQueue类，将各个功能点以组合<br>形式结合在一起。每个功能点(Request,CacheDispatcher,NetworkdDispatcher)，都是以接口或者抽象类的形式提供。红色外面的部分，为功能点提供具体实现。<br>多用组合，少用继承；针对接口编程，不针对具体实现编程。</p>
<p><strong>4、主要流程源码解析</strong><br>4.1.1<br>使用volley的时候，需要创建一个请求队列RequestQueue，最好在AppApplication中声明一个全局的RequestQueue，使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mRequestQueue = Volley.newRequestQueue(getApplicationContext());</div></pre></td></tr></table></figure>
<p>我们看一下源码中Volley中的newRequestQueue方法，就是新建一个RequestQueue类对象，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);</div><div class="line">queue.start();</div></pre></td></tr></table></figure>
<p>这段代码，将缓存对象和网络对象加入到RequestQueue队列中（其中DiskBasedCache是Cache的具体实现类，BasicNetWork是NetWork的具体实现类），RequestQueue中第二个参数network实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if (stack == null) &#123;</div><div class="line">            if (Build.VERSION.SDK_INT &gt;= 9) &#123;</div><div class="line">                stack = new HurlStack();</div><div class="line">            &#125; else &#123;</div><div class="line">               stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class="line">            &#125;</div><div class="line">     &#125;</div><div class="line">Network network = new BasicNetwork(stack);</div></pre></td></tr></table></figure>
<p>代码中可以看出来，当API&gt;=9的时候，使用HurlStack，反之，使用HttpClientStack。关于HurlStack和HttpClientStack基于什么来实现的，我会在下一章中做详细介绍。</p>
<p>4.1.2<br>添加request，使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mRequestQueue.add(request);</div></pre></td></tr></table></figure>
<p>我们看一下源码中RequestQueue中的add方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (!request.shouldCache()) &#123;</div><div class="line">            mNetworkQueue.add(request);</div><div class="line">            return request;&#125;</div></pre></td></tr></table></figure>
<p>首先判断当前请求是否可以缓存，如果不能直接添加到网络请求队列，如果可以缓存，就加入缓存队列。<br>然后判断等待请求mWaitingRequests和添加的request是否有相同的cachekey，如果有的话，将这个request加入具有相同cachekey的等待队列，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">stagedRequests.add(request);//  stagedRequests是具有cachekey的队列</div><div class="line">mWaitingRequests.put(cacheKey, stagedRequests);//mWaitingRequests是            </div><div class="line">                                              //map&lt;String,Queue&gt;类型</div></pre></td></tr></table></figure>
<p>如果没有的话，就为cachekey添加一个为null的队列，加入缓存队列mCacheQueue，相当于在内存中重新添加这个request，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mWaitingRequests.put(cacheKey, null);</div><div class="line">mCacheQueue.add(request);</div></pre></td></tr></table></figure>
<p>其中mCacheQueue和mNetworkQueue分别代表缓存请求队列和网络请求队列，mWaitingRequests是一个等待请求的集合，如果一个请求可以被缓存，并且有相同的cachekey，就可以全部进入此等待队列。</p>
<p>4.2 创建JSON请求<br>volley自带JsonObjectRequest和JsonArrayRequest来处理JSON对象请求和JSON数据请求。创建JsonObjectRequest对象，写好response回调接口，把这个请求放到请求队列中就可以了，使用方法如下(JsonArrayRequest使用方法也类似)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">JsonObjectRequest jsonObjReq = new JsonObjectRequest(Method.GET,url, null,</div><div class="line">            new Response.Listener&lt;JSONObject&gt;() &#123;</div><div class="line">      	@Override</div><div class="line">       	public void onResponse(JSONObject response) &#123;</div><div class="line">                Log.d(TAG, response.toString());</div><div class="line">             &#125;</div><div class="line">        &#125;, new Response.ErrorListener() &#123;</div><div class="line">       	@Override</div><div class="line">        public void onErrorResponse(VolleyError error) &#123;</div><div class="line">               VolleyLog.d(TAG, &quot;Error: &quot; + error.getMessage());</div><div class="line">             &#125;</div><div class="line">        &#125;);</div><div class="line">mRequestQueue.add(jsonObjReq, tag_json_obj);</div></pre></td></tr></table></figure>
<p>我们从源码分析JsonObjectRequest.java文件，JsonObjectRequest继承Response.java，就是一个结构体，里面包含了url，请求方式，onResponse和errorResponse回调。</p>
<p>4.3 创建String请求<br>volley中有StringRequest类，用来请求string类型的数据，使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">StringRequest strReq = new StringRequest(Method.GET,</div><div class="line">            url, new Response.Listener&lt;String&gt;() &#123;</div><div class="line">                @Override</div><div class="line">                public void onResponse(String response) &#123;</div><div class="line">                    Log.d(TAG, response.toString());</div><div class="line">                    pDialog.hide();</div><div class="line">                &#125;</div><div class="line">            &#125;, new Response.ErrorListener() &#123;</div><div class="line">                @Override</div><div class="line">                public void onErrorResponse(VolleyError error) &#123;</div><div class="line">                    VolleyLog.d(TAG, &quot;Error: &quot; + error.getMessage());</div><div class="line">                    pDialog.hide();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">mRequestQueue.add(strReq, tag_json_obj);</div></pre></td></tr></table></figure>
<p>StringRequest.java跟JsonRequest结构一样。</p>
<p>4.4 创建POST请求<br>上面都是GET请求，下面是POST请求，需要将请求类型改为POST类型，并且override Request中的getParams方法就可以了，使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">JsonObjectRequest jsonObjReq = new JsonObjectRequest(Method.POST,</div><div class="line">            url, null,</div><div class="line">            new Response.Listener&lt;JSONObject&gt;() &#123;</div><div class="line">                @Override</div><div class="line">                public void onResponse(JSONObject response) &#123;</div><div class="line">                    Log.d(TAG, response.toString());</div><div class="line">                    pDialog.hide();</div><div class="line">                &#125;</div><div class="line">            &#125;, new Response.ErrorListener() &#123;</div><div class="line">                @Override</div><div class="line">                public void onErrorResponse(VolleyError error) &#123;</div><div class="line">                    VolleyLog.d(TAG, &quot;Error: &quot; + error.getMessage());</div><div class="line">                    pDialog.hide();</div><div class="line">                &#125;</div><div class="line">            &#125;) &#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        protected Map&lt;String, String&gt; getParams() &#123;</div><div class="line">            Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();</div><div class="line">            params.put(&quot;name&quot;, &quot;Androidhive&quot;);</div><div class="line">            params.put(&quot;email&quot;, &quot;abc@androidhive.info&quot;);</div><div class="line">            params.put(&quot;password&quot;, &quot;password123&quot;);</div><div class="line">            return params;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>这里通过重写Request.java中的getParams方法，将POST中的参数传入到request中，类型是Map<string, string="">。</string,></p>
<p>4.5 添加头部信息<br>override Request中的getHeaders方法就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">JsonObjectRequest jsonObjReq = new JsonObjectRequest(Method.POST,url, null,new Response.Listener&lt;JSONObject&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public void onResponse(JSONObject response) &#123;</div><div class="line">        Log.d(TAG, response.toString());</div><div class="line">        pDialog.hide();</div><div class="line">    &#125;</div><div class="line">&#125;, new Response.ErrorListener() &#123;</div><div class="line">    @Override</div><div class="line">    public void onErrorResponse(VolleyError error) &#123;</div><div class="line">        VolleyLog.d(TAG, &quot;Error: &quot; + error.getMessage());</div><div class="line">        pDialog.hide();</div><div class="line">    &#125;</div><div class="line">&#125;) &#123;</div><div class="line"></div><div class="line">@Override</div><div class="line">public Map&lt;String, String&gt; getHeaders() throws AuthFailureError &#123;</div><div class="line">    HashMap&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;();</div><div class="line">    headers.put(&quot;Content-Type&quot;, &quot;application/json&quot;);</div><div class="line">    headers.put(&quot;apiKey&quot;, &quot;xxxxxxxxxxxxxxx&quot;);</div><div class="line">    return headers;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里通过重写Request.java中的getHeaders方法，将POST中的参数传入到request中，类型是Map<string, string="">。</string,></p>
<p>4.7 Volley中的Cache机制<br>1）从请求cache中加载请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Cache=mRequestQueue.getCache();</div><div class="line">Entry entry = cache.get(url);</div><div class="line">if(entry != null)&#123;</div><div class="line">    try &#123;</div><div class="line">        String data = new String(entry.data, &quot;UTF-8&quot;);</div><div class="line">    &#125; catch (UnsupportedEncodingException e) &#123;      </div><div class="line">        e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;else&#123;</div><div class="line">    // Cached response doesn&apos;t exists. Make network call here</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2）请求缓存失效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mRequestQueue.getCache().invalidate(url, true);</div></pre></td></tr></table></figure>
<p>3）关闭cache</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringRequest stringReq = new StringRequest(....);</div><div class="line">stringReq.setShouldCache(false);//true就是打开cache</div></pre></td></tr></table></figure>
<p>4）将URL的cache删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mRequestQueue.getCache().remove(url);</div></pre></td></tr></table></figure>
<p>5）删除所有cache</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mRequestQueue.getCache().clear();</div></pre></td></tr></table></figure>
<p>4.8 请求优先级<br>优先级分为：Normal, Low, Immediate, High</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">private Priority priority = Priority.HIGH;</div><div class="line">StringRequest strReq = new StringRequest(Method.GET,</div><div class="line">            Const.URL_STRING_REQ, new Response.Listener&lt;String&gt;() &#123;</div><div class="line">                @Override</div><div class="line">                public void onResponse(String response) &#123;</div><div class="line">                    Log.d(TAG, response.toString());</div><div class="line">                    msgResponse.setText(response.toString());</div><div class="line">                    hideProgressDialog();</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;, new Response.ErrorListener() &#123;</div><div class="line">                @Override</div><div class="line">                public void onErrorResponse(VolleyError error) &#123;</div><div class="line">                    VolleyLog.d(TAG, &quot;Error: &quot; + error.getMessage());</div><div class="line">                    hideProgressDialog();</div><div class="line">                &#125;</div><div class="line">            &#125;) &#123;</div><div class="line">        @Override</div><div class="line">        public Priority getPriority() &#123;</div><div class="line">            return priority;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>4.9 取消请求<br>addToRequestQueue(request, tag)方法还接受一个tag参数，这个tag就是用来标记某一类请求的，这样就可以取消这个tag的所有请求了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mRequestQueue.cancelAll(&quot;feed_request&quot;);</div></pre></td></tr></table></figure>
<p>4.10 RequestQueue的start方法<br>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void start() &#123;</div><div class="line">        stop();  // Make sure any currently running dispatchers are stopped.</div><div class="line">        // Create the cache dispatcher and start it.</div><div class="line">        mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class="line">        mCacheDispatcher.start();</div><div class="line"></div><div class="line">        // Create network dispatchers (and corresponding threads) up to the pool size.</div><div class="line">        for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</div><div class="line">            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class="line">                    mCache, mDelivery);</div><div class="line">            mDispatchers[i] = networkDispatcher;</div><div class="line">            networkDispatcher.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>CacheDispatcher是缓存分发器，只有一个，NetworkDispatcher是网络分发器，有多个，然后我再去看一下CacheDispatcher分发器中的start方法，CacheDispatcher继承的Thread，所以直接看run方法，代码如下（注释我写在代码上面）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">public void run() &#123;</div><div class="line">        if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);</div><div class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line"></div><div class="line">        // Make a blocking call to initialize the cache.</div><div class="line">        mCache.initialize();</div><div class="line"></div><div class="line">        while (true) &#123;</div><div class="line">            try &#123;               </div><div class="line">                final Request&lt;?&gt; request = mCacheQueue.take();</div><div class="line">                request.addMarker(&quot;cache-queue-take&quot;);</div><div class="line">                </div><div class="line">                if (request.isCanceled()) &#123;</div><div class="line">                    request.finish(&quot;cache-discard-canceled&quot;);</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Attempt to retrieve this item from cache.</div><div class="line">                //尝试从缓存中获取响应结果</div><div class="line">                Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class="line">                //如果缓存中获取结果为空的话,就把这个请求放到网络请求队列中</div><div class="line">                if (entry == null) &#123;</div><div class="line">                    request.addMarker(&quot;cache-miss&quot;);</div><div class="line">                    // Cache miss; send off to the network dispatcher.</div><div class="line">                    mNetworkQueue.put(request);</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                //如果缓冲结果不为空的话,判断缓存是否过期</div><div class="line">                //如果过期的话,将这个请求放到网络请求队列中.</div><div class="line">                if (entry.isExpired()) &#123;</div><div class="line">                    request.addMarker(&quot;cache-hit-expired&quot;);</div><div class="line">                    request.setCacheEntry(entry);</div><div class="line">                    mNetworkQueue.put(request);</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                //直接使用缓存中的数据</div><div class="line">                request.addMarker(&quot;cache-hit&quot;);</div><div class="line">                //parseNetworkResponse对数据进行解析</div><div class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class="line">                        new NetworkResponse(entry.data, entry.responseHeaders));</div><div class="line">                request.addMarker(&quot;cache-hit-parsed&quot;);</div><div class="line"></div><div class="line">                //将解析出来的数据进行回调.</div><div class="line">                if (!entry.refreshNeeded()) &#123;</div><div class="line">                    // Completely unexpired cache hit. Just deliver the response.</div><div class="line">                    mDelivery.postResponse(request, response);</div><div class="line">                &#125; else &#123;</div><div class="line">                    request.addMarker(&quot;cache-hit-refresh-needed&quot;);</div><div class="line">                    request.setCacheEntry(entry);</div><div class="line">                    response.intermediate = true;</div><div class="line">                    </div><div class="line">                    mDelivery.postResponse(request, response, new Runnable() &#123;</div><div class="line">                        @Override</div><div class="line">                        public void run() &#123;</div><div class="line">                            try &#123;</div><div class="line">                                mNetworkQueue.put(request);</div><div class="line">                            &#125; catch (InterruptedException e) &#123;</div><div class="line">                                // Not much we can do about this.</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125; catch (InterruptedException e) &#123;                </div><div class="line">                if (mQuit) &#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>其中cache结构体中的内容，如上面介绍的cache机制的方法向cache中添加信息和内容。<br>同理，networkDispatcher中run方法源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public void run() &#123;</div><div class="line">       Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">       while (true) &#123;</div><div class="line">           long startTimeMs = SystemClock.elapsedRealtime();</div><div class="line">           Request&lt;?&gt; request;</div><div class="line">           try &#123;</div><div class="line">               request = mQueue.take();</div><div class="line">           &#125; catch (InterruptedException e) &#123;</div><div class="line">               if (mQuit) &#123;</div><div class="line">                   return;</div><div class="line">               &#125;</div><div class="line">               continue;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           try &#123;</div><div class="line">               request.addMarker(&quot;network-queue-take&quot;);</div><div class="line">               if (request.isCanceled()) &#123;</div><div class="line">                   request.finish(&quot;network-discard-cancelled&quot;);</div><div class="line">                   continue;</div><div class="line">               &#125;</div><div class="line">               addTrafficStatsTag(request);</div><div class="line">               //发送网络请求</div><div class="line">               NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class="line">               request.addMarker(“network-http-complete&quot;);</div><div class="line"></div><div class="line">               if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">                   request.finish(&quot;not-modified&quot;);</div><div class="line">                   continue;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">           // 在子线程中解析，在Request子类中parseNetworkResponse方法中实现解析</div><div class="line">               Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class="line">               request.addMarker(“network-parse-complete&quot;);</div><div class="line"></div><div class="line">              if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123;</div><div class="line">                   mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class="line">                   request.addMarker(&quot;network-cache-written&quot;);</div><div class="line">               &#125;</div><div class="line">               // response回调.</div><div class="line">               request.markDelivered();</div><div class="line">               mDelivery.postResponse(request, response);</div><div class="line">           &#125; catch (VolleyError volleyError) &#123;</div><div class="line">               volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class="line">               parseAndDeliverNetworkError(request, volleyError);</div><div class="line">           &#125; catch (Exception e) &#123;</div><div class="line">               VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());</div><div class="line">               VolleyError volleyError = new VolleyError(e);</div><div class="line">               volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class="line">               mDelivery.postError(request, volleyError);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>代码比较多，但是真正网络请求的核心代码应该是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NetworkResponse networkResponse = mNetwork.performRequest(request);</div></pre></td></tr></table></figure>
<p>最核心的是performRequest方法，具体代码分析我放到下一章节。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/27/Volley源码解析(一)/" data-id="ciw6kt7bn000bpmugiagaojw5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/volley/">volley</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存/">内存</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/框架/">框架</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计/">设计</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-image-loader" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/06/image-loader/" class="article-date">
  <time datetime="2016-06-06T09:12:18.000Z" itemprop="datePublished">2016-06-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/06/image-loader/">ImageLoader源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>功能介绍<br>总体设计<br>流程图<br>源码解析<br>LoadAndDisplayImageTask实现流程</p>
<h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p><strong><em>1.1介绍</em></strong><br>android image loader是一个强大的、可以高度定制的图片缓存，主要工作就是获取图片并且显示在相应控件上。</p>
<p><strong><em>1.2.1初始化</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">options = new DisplayImageOptions.Builder()</div><div class="line">	.showImageOnLoading(R.drawable.ic_stub)</div><div class="line">	.showImageForEmptyUri(R.drawable.ic_empty)</div><div class="line">	.showImageOnFail(R.drawable.ic_error)</div><div class="line">	.cacheInMemory(true)</div><div class="line">	.cacheOnDisk(true)</div><div class="line">	.considerExifParams(true)</div><div class="line">	.displayer(new CircleBitmapDisplayer(Color.WHITE, 5))</div><div class="line">	.build();</div><div class="line">ImageLoader.getInstance().displayImage(IMAGE_URLS[position], holder.image, options, animateFirstListener);</div></pre></td></tr></table></figure>
<p>options是imageloader的配置信息，包括图片最大尺寸、线程池、缓存、下载器、解码器等</p>
<p><strong><em>1.2.2 Manifest配置</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</div><div class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</div></pre></td></tr></table></figure>
<p>添加网络权限和写外设的权限。</p>
<p><strong><em>1.2.3 下载显示图片</em></strong><br>有以下两种方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">imageLoader.displayImage(imageUri, imageView);</div><div class="line">imageLoader.loadImage(imageUri, new SimpleImageLoadingListener() &#123;</div><div class="line">    @Override</div><div class="line">    public void onLoadingComplete(String imageUri, View   view, Bitmap loadedImage) &#123;</div><div class="line">        // 图片处理</div><div class="line">    &#125;</div><div class="line">&#125;);//为bitmap传递给回调接口</div></pre></td></tr></table></figure>
<p><strong><em>1.3 特点</em></strong><br>——两级缓存，内存缓存和硬盘缓存<br>——多线程，异步或者同步加载图片<br>——可配置，支持任务线程池、下载器、解码器、内存、硬盘缓存等<br>——支持多种缓存算法、下载进度监听、listview图片错乱解决等</p>
<p><strong>2、总体设计</strong></p>
<p><strong><em>2.1 设计图</em></strong><br>UI设计图如下：<br><img src="http://img.blog.csdn.net/20160606164351384" alt="这里写图片描述"><br>整个库分为：<br>ImageLoaderEngine,Cache和ImageDownLoader,ImageDecoder,BitmapDisplayer,BitmapProcessor五个模块，其中cache分为内存缓存(DiskCache)和硬盘缓存(MemoryCache)。<br>ImageLoader获取图片，然后交给ImageLoaderEngine，ImageLoaderEngine中分发任务到具体线程(LoadAndDisplayImageTask和ProcessAndDisplayImageTask)，通过Cache和ImageDownLoader获取图片(LoadAndDisplayImageTask线程)，也有可能经过BimapProcessor和ImageDecoder(ProcessAndDisplyImageTask线程)，最终转化为bitmap，BitmapDisplayer将bitmap显示在ImageAware。</p>
<p><strong><em>2.2 概念</em></strong><br>ImageLoaderEngine：<br>任务分发器，负责分发LoadAndDisplayImageTask和ProcessAndDisplayImageTask给具体的线程去执行。ImageLoaderEngine.java<br>ImageAware：显示图片对象，可以是ImageView等。ImageAware.java<br>ImageDownloader：图片下载器，从来源获取输入流。BaseImageDownloader.java<br>MemoryCache：向内存缓存中读取图片。BaseMemoryCache.java<br>DiskCache：向本地磁盘缓存中读取图片。BaseDiskCache.java<br>ImageDecoder：图片解码器，将图片输入流InputStream转化为bitmap。BaseImageDecoder.java<br>BitmapDisplayer：将bitmap对象显示在ImageAware上。接口文件BitmapDisplayer.java<br>LoadAndDisplayImageTask：加载并显示图片。LoadAndDisplayImageTask.java<br>ProcessAndDisplayImageTask：处理并显示图片。ProcessAndDisplayImageTask.java<br>DisplayBitmapTask：显示图片。DisplayBitmapTask.java</p>
<p><strong><em>3、流程图</em></strong></p>
<p><img src="http://img.blog.csdn.net/20160606164836859" alt="这里写图片描述"></p>
<p><strong><em>4、用到文件的源码解析</em></strong><br>下面文件是一些imageloader中用的文件，具体代码注释可以去我的github上。</p>
<p>4.1 ImageLoader</p>
<p>4.1.1 ImageLoader.java<br><code>public void displayImage(String uri, ImageAware imageAware, DisplayImageOptions options,ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener)</code></p>
<p>注解可以看一下我的github，参数解释如下：<br>uri：图片url，支持HTTP(“http”), HTTPS(“https”), FILE(“file”), CONTENT(“content”), ASSETS(“assets”), DRAWABLE(“drawable”), UNKNOWN(“”)<br>imageAware：需要加载图片的对象，width，height，scaleType，id等<br>options：图片显示配置项，imageOnLoading（加载中），imageOnFail（加载失败显示的图片），cacheOnDisk（图片是否需要缓存到硬盘中），cacheInMemory（图片是否需要缓存到内存中）等<br>listener：图片加载的时候回调接口，onLoadingStarted，onLoadingFailed，onLoadingComplete，onLoadingCancelled。<br>processListener：图片加载进度的接口，onProgressUpdate。</p>
<p>4.1.2 ImageLoaderConfiguration</p>
<p>4.1.3 ImageLoaderConfiguration.builder</p>
<p>4.1.4 ImageLoaderConfiguration中的SlowNetworkImageDownloader.java 静态内部类</p>
<p>4.1.5 ImageLoaderConfiguration中的NetworkDeniedImageDownloader.java静态内部类</p>
<p>4.2 ImageLoaderEngine.java<br>LoadAndDisplayImageTask和ProcessAndDisplayImageTask任务分发器，负责分发任务给具体的线程池。</p>
<p>4.3 DefaultConfigurationFactory.java<br>默认配置。</p>
<p>4.4 ImageAware.java</p>
<p>4.5 ViewAware.java<br>实现ImageAware接口的抽象类，利用Reference来Warp View防止内存泄露。</p>
<p>4.6 ImageViewAware.java</p>
<p>4.7 NoneViewAware.java<br>处理图片相关信息却没有需要显示图片的 View 的ImageAware，实现了ImageAware接口。常用于加载图片后调用回调接口而不是显示的情况。</p>
<p>4.8 DisplayImageOptions.java<br>图片显示的配置项。比如加载前、中、失败应该显示的图片，图片是否需要在磁盘中缓存，是否需要在内存中缓存等。</p>
<p>4.8.1 DisplayImageOptions.Builder静态内部类</p>
<p>4.9 SimpleImageLoadingListener.java<br>ImageLoader.displayImage(…)中的listener，实现回调</p>
<p>4.10 ImageLoadingProgressListener.java<br>Image加载进度的回调接口。</p>
<p>4.11 DisplayBitmapTask.java<br>显示图片的task，必须要在主线程中调用<br>我之前写了一个内存缓存的显示imageview的相册选择器，在下拉的时候，因为异步加载和view复用的时候，会导致图片显示混乱。DisplayBitmapTask.java中的run中，使用方法isViewWasReused来判断imageAware是否被复用就可以解决这个问题，isViewWasReused就是根据当前正在加载的图片的key和缓存中的key进行比较，如果不相等，就返回true，如果相等，就返回false，当isViewWasReused为true的时候，取消加载。即当前加载图片必须要跟缓存中的图片一致才能继续加载该图片，防止图片显示混乱。</p>
<p>4.12  ProcessAndDisplayImageTask.java<br>处理并显示图片。</p>
<p>4.13 LoadAndDisplayImageTask.java<br>加载并显示图片，task从网络、文件系统或者内存中获取图片并解析，然后调用DisplayBitmapTask在ImageAware中显示图片。<br>详细的LoadAndDisplayImageTask实现流程可以看第五部分的内容。</p>
<p>4.14 ImageLoadingInfo.java<br>加载和显示图片任务需要的信息。</p>
<p>4.15 ImageDownloader.java<br>图片下载接口</p>
<p>4.16 BaseImageDownloader.java<br>ImageDownloader的具体实现类。得到Scheme对应的照片InputStream。</p>
<p>4.17 BaseMemoryCache.java<br>实现memoryCache主要函数的抽象类。</p>
<p>4.18 WeakMemoryCache.java<br>以WeakReference<bitmap>做为缓存 value 的内存缓存，实现了BaseMemoryCache。<br>实现了BaseMemoryCache的createReference(Bitmap value)函数，直接返回一个new WeakReference<bitmap>(value)做为缓存 value。</bitmap></bitmap></p>
<p>4.19 LimitedMemoryCache.java<br>限制总体字节大小的内存缓存。</p>
<p>4.20 LargestLimitedMemoryCache.java<br>继承LimitedMemoryCache，在缓存满的时候优先删除size最大的元素，实现LimitedMemoryCache中的removeNext抽象函数。</p>
<p>4.21 UsingFreqLimitedMemoryCache.java<br>继承LimitedMemoryCache，在缓存满的时候优先删除使用次数最少的元素。</p>
<p>4.22 LRULimitedMemoryCache.java<br>优先删除最近最少使用的元素。</p>
<p>4.23 FIFOLimitedMemoryCache.java<br>删除优先进入缓存的元素。</p>
<p>4.24 LimitedAgeMemoryCache.java</p>
<p>4.25 FuzzyKeyMemoryCache.java</p>
<p>4.26 FileNameGenerator.java<br>根据uri得到文件名的接口。</p>
<p>4.27 HashCodeFileNameGenerator.java<br>以uri的hashcode作为文件名。</p>
<p>4.28 Md5FileNameGenerator.java<br>以uri的MD5值作为文件名。</p>
<p>4.29 DiskCache.java<br>图片的磁盘缓存接口。</p>
<p>4.30 BaseDiskCache.java<br>一个没有大小限制的本地图片缓存，实现了DiskCache主要函数的抽象类</p>
<p>4.31 LimitedAgeDiskCache.java<br>限制缓存周期的磁盘缓存，继承BaseDiskCache</p>
<p>4.32 UnlimitedDiskCache.java<br>无大小限制的图片缓存。</p>
<p>4.33 DiskLruCache.java<br>限制总体字节大小的内存缓存，内存满的时候优先删除最少使用的元素。</p>
<p>4.34 LruDiskCache.java<br>限制总字节大小的内存缓存，缓存满时优先删除最近最少使用的元素。</p>
<p>4.35 FailReason.java<br>图片下载及显示时的错误原因，目前包括：<br>IO_ERROR 网络连接或是磁盘存储错误。<br>DECODING_ERROR decode image 为 Bitmap 时错误。<br>NETWORK_DENIED 当图片不在缓存中，且设置不允许访问网络时的错误。<br>OUT_OF_MEMORY 内存溢出错误。<br>UNKNOWN 未知错误。</p>
<p>4.36  ImageScaleType.java<br>NONE不缩放。<br>NONE_SAFE根据需要以整数倍缩小图片，使得其尺寸不超过 Texture 可接受最大尺寸。<br>IN_SAMPLE_POWER_OF_2根据需要以 2 的 n 次幂缩小图片，使其尺寸不超过目标大小，比较快的缩小方式。<br>IN_SAMPLE_INT根据需要以整数倍缩小图片，使其尺寸不超过目标大小。<br>EXACTLY根据需要缩小图片到宽或高有一个与目标尺寸一致。<br>EXACTLY_STRETCHED根据需要缩放图片到宽或高有一个与目标尺寸一致。</p>
<p>4.37 ViewScaleType.java<br>ImageAware的 ScaleType。<br>将 ImageView 的 ScaleType 简化为两种FIT_INSIDE和CROP两种。FIT_INSIDE表示将图片缩放到至少宽度和高度有一个小于等于 View 的对应尺寸，CROP表示将图片缩放到宽度和高度都大于等于 View 的对应尺寸。</p>
<p>4.38 ImageSize.java<br>scaleDown(…) 等比缩小宽高。<br>scale(…) 等比放大宽高。</p>
<p>4.39 LoadedFrom.java<br>图片来源，包括网络、硬盘缓存、内存缓存等。</p>
<p>4.40 ImageDecoder.java<br>将图片转换为Bitmap接口，抽象函数：decode（ImageDecodingInfo imageDecodingInfo），根据ImageDecodingInfo信息得到图片并将其转换为Bitmap。</p>
<p>4.41 BaseImageDecoder.java<br>实现了ImageDecoder。调用ImageDownloader获取图片，然后根据ImageDecodingInfo或图片 Exif 信息处理图片转换为 Bitmap。</p>
<p>4.42 ImageDecodingInfo.java</p>
<p>4.43 BitmapDisplay.java</p>
<p>4.44 FadeInBitmapDisplayer.java<br>图片淡入方式显示在ImageAware中，实现BitmapDisplayer接口</p>
<p>4.45 RoundedBitmapDisplayer.java<br>为图片添加圆角显示在ImageAware中</p>
<p>4.46 RoundedVignetteBitmapDisplayer.java<br>为图片添加渐变效果的圆角显示在ImageAware中。</p>
<p>4.47 SimpleBitmapDisplay.java<br>直接将图片显示在ImageAware中。<br>Image Decoder需要的信息</p>
<p>4.48 PauseOnScrollListener.java<br>在View滚动过程中暂停图片加载的Listener，实现OnScrollListener接口。<br>实现原理：<br>重写onScrollStateChanged(…)函数判断不同的状态下暂停或继续图片加载。<br>OnScrollListener.SCROLL_STATE_IDLE表示 View 处于空闲状态，没有在滚动，这时候会加载图片。<br>OnScrollListener.SCROLL_STATE_TOUCH_SCROLL表示 View 处于触摸滑动状态，手指依然在屏幕上，通过pauseOnScroll变量确定是否需要暂停图片加载。这种时候大都属于慢速滚动浏览状态，所以建议继续图片加载。<br>OnScrollListener.SCROLL_STATE_FLING表示 View 处于甩指滚动状态，手指已离开屏幕，通过pauseOnFling变量确定是否需要暂停图片加载。这种时候大都属于快速滚动状态，所以建议暂停图片加载以节省资源。</p>
<p><strong><em>5 LoadAndDisplayImageTask实现流程</em></strong></p>
<p>流程图如下：<br>1）判断图片的内存缓存是否存在，若存在直接执行步骤 8；<br>2）判断图片的磁盘缓存是否存在，若存在直接执行步骤 5；<br>3）从网络上下载图片；<br>4）将图片缓存在磁盘上；<br>5）将图片 decode 成 bitmap 对象；<br>6）根据DisplayImageOptions配置对图片进行预处理(Pre-process Bitmap)；<br>7）将 bitmap 对象缓存到内存中；<br>8）根据DisplayImageOptions配置对图片进行后处理(Post-process Bitmap)；<br>9）执行DisplayBitmapTask将图片显示在相应的控件上。<br><img src="http://img.blog.csdn.net/20160606170806858" alt="这里写图片描述"></p>
<p>具体代码注释，我都push到我的github上，有兴趣的同学可以点击下面的链接，去我github上fork一下项目。</p>
<p><a href="https://github.com/LonerJimmy/Android-Universal-Image-Loader" target="_blank" rel="external"><strong><em>具体代码注释看请我的github</em></strong></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/06/image-loader/" data-id="ciw6kt7by000mpmugcsbdy6f2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/缓存/">缓存</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android自定义手势解锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/26/android自定义手势解锁/" class="article-date">
  <time datetime="2016-05-26T11:16:18.000Z" itemprop="datePublished">2016-05-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/26/android自定义手势解锁/">android自定义手势解锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一个手势解锁的view(仿照支付宝手势解锁的样式)，可以改变手势解锁的颜色、样式（目前只有两种样式）、大小等等。 </p>
<p>1、需要在整个项目的build.gradle中添加如下依赖项（jcenter暂时没有传上去）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">allprojects &#123;</div><div class="line">    repositories &#123;</div><div class="line">        maven &#123;</div><div class="line">            url  &quot;http://dl.bintray.com/loner/maven&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2、在自己app的build.gradle中添加如下依赖项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile &apos;loner.library.gesture:gesture:1.0.1&apos;</div></pre></td></tr></table></figure>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><strong>1、首先在layout文件中显示view</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;loner.widget.lockpattern.view.LockPatternSmallView</div><div class="line">    android:id=&quot;@+id/mLocusPassWordViewFirstRegisterSmall&quot;</div><div class="line">       android:layout_gravity=&quot;center&quot;</div><div class="line">       android:layout_width=&quot;50dp&quot;</div><div class="line">       android:layout_height=&quot;50dp&quot; &gt;</div><div class="line"> &lt;/loner.widget.lockpattern.view.LockPatternSmallView&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;loner.widget.lockpattern.view.LockPatternView</div><div class="line">      android:id=&quot;@+id/mLocusPassWordViewFirstRegister&quot;</div><div class="line">      android:layout_gravity=&quot;center&quot;</div><div class="line">      android:layout_width=&quot;350dp&quot;</div><div class="line">      android:layout_height=&quot;350dp&quot; &gt;</div><div class="line">&lt;/loner.widget.lockpattern.view.LockPatternView&gt;</div></pre></td></tr></table></figure>
<p>LockPatternSmallView是小数字键盘，LockPatternView是大数字键盘。<br>这里有几个属性简单介绍一下(使用方法就是在view下面添加app:pressColor=” “)：</p>
<ul>
<li>pressColor表示按下是按钮的颜色。 </li>
<li>initColor表示初始时按钮的颜色。</li>
<li>errorColor表示按下是按钮的颜色。 </li>
<li>style表示手势解锁样式，目前只有0和1两种样式，大家可以试试</li>
<li>radius表示手势解锁键盘的圆圈半径</li>
</ul>
<p><strong>2、在java文件中声明两个view变量，一个是大键盘，一个是小键盘，如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private LockPatternView lpv;</div><div class="line">private LockPatternSmallView lpvs;</div><div class="line">lpv=(LockPatternView)findViewById(R.id.mLocusPassWordViewFirstRegister);</div><div class="line">lpvs=(LockPatternSmallView)findViewById(R.id.mLocusPassWordViewFirstRegisterSmall);</div></pre></td></tr></table></figure>
<p><strong>3、更多使用方法</strong></p>
<p>（1）通过一个回调方法来获取键盘数字密码，写法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lpv.setOnCompleteListener(new LockPatternView.OnCompleteListener() &#123;</div><div class="line">    @Override</div><div class="line">    public void onComplete(String mPassword) &#123;</div><div class="line">            ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>onComplete函数就是当键盘输入结束后触发的函数。<br>onComplete函数中的参数mPassword就是键盘输入结束后的密码，然后在onComplete函数中进行操作。<br>九宫格标记如下</p>
<p>1          2         3<br>4          5         6<br>7          8         9</p>
<p>密码记录的是每个格子的标记，中间用”,”隔开。<br>mPassword=””的时候，及手势密码位数小于5。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (mPassword.equals(&quot;&quot;)) &#123;//手势密码位数不正确</div><div class="line">    txtTitle.setText(&quot;手势密码不合规范&quot;); </div><div class="line">    txtTitle.setTextColor(Color.RED);            </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>（2）设置键盘不可touch</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lpv.disableTouch();</div></pre></td></tr></table></figure>
<p>（3）清空键盘</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lpv.clearPassword();</div></pre></td></tr></table></figure>
<p>（4）设置错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lpv.error();</div></pre></td></tr></table></figure>
<p>（5）保存密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lpv.setPassWord();</div></pre></td></tr></table></figure>
<p>（6）设置小键盘显示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lpvs.setOndraw(FirstPassword);</div></pre></td></tr></table></figure>
<p>FirstPassword就是String类型，String格式就是mPassword格式。</p>
<p>（7）密码保存存放到sharedpreference，获取密码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SharedPreferences settings = this.getSharedPreferences(&quot;Gesture_Lock&quot;,MODE_PRIVATE);</div><div class="line">txtPassword.setText(settings.getString(&quot;password&quot;, &quot;&quot;));</div></pre></td></tr></table></figure>
<p>（8）设置密码长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lpv.setPasswordMinLength(3);</div></pre></td></tr></table></figure>
<p><a href="https://github.com/LonerJimmy/LockPatternDemo" target="_blank" rel="external">demo以及源码下载</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/26/android自定义手势解锁/" data-id="ciw6kt7bu000hpmug99ef9g3p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/touch/">touch</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/view/">view</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/支付宝/">支付宝</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/自定义/">自定义</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Weapp/">Weapp</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/annotations/">annotations</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/app/">app</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/camera/">camera</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dp/">dp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/glide/">glide</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gridview/">gridview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/inflater/">inflater</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/layout/">layout</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/native/">native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/picasso/">picasso</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/support/">support</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/touch/">touch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/view/">view</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/viewgroup/">viewgroup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/volley/">volley</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/weChat/">weChat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webview/">webview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存/">内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数/">函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图片/">图片</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/对象/">对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/布局/">布局</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/支付宝/">支付宝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/框架/">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程/">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/缓存/">缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自定义/">自定义</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计/">设计</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/annotations/" style="font-size: 10px;">annotations</a> <a href="/tags/app/" style="font-size: 10px;">app</a> <a href="/tags/camera/" style="font-size: 12.5px;">camera</a> <a href="/tags/dp/" style="font-size: 10px;">dp</a> <a href="/tags/glide/" style="font-size: 12.5px;">glide</a> <a href="/tags/gridview/" style="font-size: 10px;">gridview</a> <a href="/tags/inflater/" style="font-size: 10px;">inflater</a> <a href="/tags/layout/" style="font-size: 10px;">layout</a> <a href="/tags/native/" style="font-size: 12.5px;">native</a> <a href="/tags/picasso/" style="font-size: 10px;">picasso</a> <a href="/tags/support/" style="font-size: 10px;">support</a> <a href="/tags/touch/" style="font-size: 12.5px;">touch</a> <a href="/tags/view/" style="font-size: 12.5px;">view</a> <a href="/tags/viewgroup/" style="font-size: 10px;">viewgroup</a> <a href="/tags/volley/" style="font-size: 15px;">volley</a> <a href="/tags/weChat/" style="font-size: 10px;">weChat</a> <a href="/tags/webview/" style="font-size: 10px;">webview</a> <a href="/tags/内存/" style="font-size: 10px;">内存</a> <a href="/tags/函数/" style="font-size: 10px;">函数</a> <a href="/tags/图片/" style="font-size: 10px;">图片</a> <a href="/tags/对象/" style="font-size: 10px;">对象</a> <a href="/tags/布局/" style="font-size: 12.5px;">布局</a> <a href="/tags/支付宝/" style="font-size: 10px;">支付宝</a> <a href="/tags/框架/" style="font-size: 10px;">框架</a> <a href="/tags/源码/" style="font-size: 17.5px;">源码</a> <a href="/tags/线程/" style="font-size: 10px;">线程</a> <a href="/tags/缓存/" style="font-size: 12.5px;">缓存</a> <a href="/tags/网络/" style="font-size: 10px;">网络</a> <a href="/tags/自定义/" style="font-size: 10px;">自定义</a> <a href="/tags/设计/" style="font-size: 10px;">设计</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/12/01/基于ReactNative和Realm的开源项目/">自定义相机遇到的坑总结</a>
          </li>
        
          <li>
            <a href="/2016/12/01/自定义相机踩过的坑/">自定义相机踩过的坑</a>
          </li>
        
          <li>
            <a href="/2016/09/26/微信小程序学习资料汇总/">微信小程序学习资料汇总</a>
          </li>
        
          <li>
            <a href="/2016/09/26/一个自定义的GridLayout/">一个自定义的GridLayout</a>
          </li>
        
          <li>
            <a href="/2016/09/13/LayoutInflater原理解析/">深入了解View（一）——LayoutInflater原理分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>
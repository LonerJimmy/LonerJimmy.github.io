<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Volley源码解析(一) | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="这个章节，我先介绍volley功能介绍、总体设计、类设计、主要流程的源码解析，其他方法，例如图片加载、HurlStack、HttpClientStack、performRequest等，我会在后面进行介绍。
1、功能介绍1.1 volley是异步网络请求框架和图片加载器。1.2 优点       1、请求队列和请求优先级。       2、请求Cache和内存管理。       3、扩展性强，大多">
<meta property="og:type" content="article">
<meta property="og:title" content="Volley源码解析(一)">
<meta property="og:url" content="http://yoursite.com/2016/06/27/Volley源码解析(一)/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="这个章节，我先介绍volley功能介绍、总体设计、类设计、主要流程的源码解析，其他方法，例如图片加载、HurlStack、HttpClientStack、performRequest等，我会在后面进行介绍。
1、功能介绍1.1 volley是异步网络请求框架和图片加载器。1.2 优点       1、请求队列和请求优先级。       2、请求Cache和内存管理。       3、扩展性强，大多">
<meta property="og:image" content="http://img.blog.csdn.net/20160627191325478">
<meta property="og:image" content="http://img.blog.csdn.net/20160627191431652">
<meta property="og:image" content="http://img.blog.csdn.net/20160627191513387">
<meta property="og:updated_time" content="2016-11-30T23:07:34.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Volley源码解析(一)">
<meta name="twitter:description" content="这个章节，我先介绍volley功能介绍、总体设计、类设计、主要流程的源码解析，其他方法，例如图片加载、HurlStack、HttpClientStack、performRequest等，我会在后面进行介绍。
1、功能介绍1.1 volley是异步网络请求框架和图片加载器。1.2 优点       1、请求队列和请求优先级。       2、请求Cache和内存管理。       3、扩展性强，大多">
<meta name="twitter:image" content="http://img.blog.csdn.net/20160627191325478">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Volley源码解析(一)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/27/Volley源码解析(一)/" class="article-date">
  <time datetime="2016-06-27T11:30:18.000Z" itemprop="datePublished">2016-06-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Volley源码解析(一)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这个章节，我先介绍volley功能介绍、总体设计、类设计、主要流程的源码解析，其他方法，例如图片加载、HurlStack、HttpClientStack、performRequest等，我会在后面进行介绍。</p>
<p><strong>1、功能介绍</strong><br>1.1 volley是异步网络请求框架和图片加载器。<br>1.2 优点<br>       1、请求队列和请求优先级。<br>       2、请求Cache和内存管理。<br>       3、扩展性强，大多是基于接口的设计，可配置型强。<br>       4、可以取消请求。<br>       5、提供简单的图片加载工具。</p>
<p><strong>2、总体设计</strong><br>2.1 总体设计图如下：<br><img src="http://img.blog.csdn.net/20160627191325478" alt="这里写图片描述"><br>通过Dispatch Thread不断从RequestQueue中获取请求，根据是否已缓存调用Cache或者Network这两类数据获取接口其中之一，从内存缓存或者是服务器中获取数据，然后交给ResponseDelivery去做结果分发以及回调处理。</p>
<p>2.2 核心功能点概念<br>volley使用，通过newRequestQueue()函数新建并启动一个请求队列RequestQueue，然后不断向这个队列中添加Request就可以了。<br>Volley：对外暴露的API，通过newRequestQueue()函数新建并启动一个请求队列RequestQueue。<br>Request：表示一个请求的抽象类。StringRequest、JsonRequest、ImageRequest都是它的子类，表示某种类型的请求。<br>RequestQueue：请求队列，里面包含一个CacheDispatcher（缓存请求的线程）、多个NetworkDispatcher（处理网络请求的线程），start函数启动CacheDispatcher和NetworkDispatcher。<br>CacheDispatcher：用于处理缓存请求。不断从缓存请求队列中获取请求处理，队列为空的时候则等待，请求处理结束后将结果传递给ResponseDelivery去执行后续处理。当结果没有被缓存过、缓存失效等情况下，这个请求都要重新进入NetworkDispatcher去调度处理。<br>NetworkDispatcher：用于处理网络请求。不断从网络请求队列中获取请求处理，队列为空的时候则等待，请求结果传递给ResponseDelivery去执行后续处理，并判断结果是否要进行缓存。<br>ResponseDelivery：返回结果分发接口。<br>HttpStack：处理Http请求，返回请求结果。目前Volley中有基于HttpURLConnection的HurlStack和基于Apache HttpClient的HttpClientStack。<br>Network：调用HttpStack处理请求，将结果转化为可以被ResponseDelivery处理的NetworkResponse。<br>Cache：缓存请求结果，默认使用sdcard的DiskBasedCache。NetworkDispatcher得到结果后判断是否需要存在Cache，CacheDispatcher会从Cache中获取缓存结果。<br>2.3 流程图<br><img src="http://img.blog.csdn.net/20160627191431652" alt="这里写图片描述"></p>
<p>3、类设计图<br><img src="http://img.blog.csdn.net/20160627191513387" alt="这里写图片描述"><br>红色部分，围绕RequestQueue类，将各个功能点以组合<br>形式结合在一起。每个功能点(Request,CacheDispatcher,NetworkdDispatcher)，都是以接口或者抽象类的形式提供。红色外面的部分，为功能点提供具体实现。<br>多用组合，少用继承；针对接口编程，不针对具体实现编程。</p>
<p><strong>4、主要流程源码解析</strong><br>4.1.1<br>使用volley的时候，需要创建一个请求队列RequestQueue，最好在AppApplication中声明一个全局的RequestQueue，使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mRequestQueue = Volley.newRequestQueue(getApplicationContext());</div></pre></td></tr></table></figure>
<p>我们看一下源码中Volley中的newRequestQueue方法，就是新建一个RequestQueue类对象，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);</div><div class="line">queue.start();</div></pre></td></tr></table></figure>
<p>这段代码，将缓存对象和网络对象加入到RequestQueue队列中（其中DiskBasedCache是Cache的具体实现类，BasicNetWork是NetWork的具体实现类），RequestQueue中第二个参数network实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if (stack == null) &#123;</div><div class="line">            if (Build.VERSION.SDK_INT &gt;= 9) &#123;</div><div class="line">                stack = new HurlStack();</div><div class="line">            &#125; else &#123;</div><div class="line">               stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class="line">            &#125;</div><div class="line">     &#125;</div><div class="line">Network network = new BasicNetwork(stack);</div></pre></td></tr></table></figure>
<p>代码中可以看出来，当API&gt;=9的时候，使用HurlStack，反之，使用HttpClientStack。关于HurlStack和HttpClientStack基于什么来实现的，我会在下一章中做详细介绍。</p>
<p>4.1.2<br>添加request，使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mRequestQueue.add(request);</div></pre></td></tr></table></figure>
<p>我们看一下源码中RequestQueue中的add方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (!request.shouldCache()) &#123;</div><div class="line">            mNetworkQueue.add(request);</div><div class="line">            return request;&#125;</div></pre></td></tr></table></figure>
<p>首先判断当前请求是否可以缓存，如果不能直接添加到网络请求队列，如果可以缓存，就加入缓存队列。<br>然后判断等待请求mWaitingRequests和添加的request是否有相同的cachekey，如果有的话，将这个request加入具有相同cachekey的等待队列，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">stagedRequests.add(request);//  stagedRequests是具有cachekey的队列</div><div class="line">mWaitingRequests.put(cacheKey, stagedRequests);//mWaitingRequests是            </div><div class="line">                                              //map&lt;String,Queue&gt;类型</div></pre></td></tr></table></figure>
<p>如果没有的话，就为cachekey添加一个为null的队列，加入缓存队列mCacheQueue，相当于在内存中重新添加这个request，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mWaitingRequests.put(cacheKey, null);</div><div class="line">mCacheQueue.add(request);</div></pre></td></tr></table></figure>
<p>其中mCacheQueue和mNetworkQueue分别代表缓存请求队列和网络请求队列，mWaitingRequests是一个等待请求的集合，如果一个请求可以被缓存，并且有相同的cachekey，就可以全部进入此等待队列。</p>
<p>4.2 创建JSON请求<br>volley自带JsonObjectRequest和JsonArrayRequest来处理JSON对象请求和JSON数据请求。创建JsonObjectRequest对象，写好response回调接口，把这个请求放到请求队列中就可以了，使用方法如下(JsonArrayRequest使用方法也类似)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">JsonObjectRequest jsonObjReq = new JsonObjectRequest(Method.GET,url, null,</div><div class="line">            new Response.Listener&lt;JSONObject&gt;() &#123;</div><div class="line">      	@Override</div><div class="line">       	public void onResponse(JSONObject response) &#123;</div><div class="line">                Log.d(TAG, response.toString());</div><div class="line">             &#125;</div><div class="line">        &#125;, new Response.ErrorListener() &#123;</div><div class="line">       	@Override</div><div class="line">        public void onErrorResponse(VolleyError error) &#123;</div><div class="line">               VolleyLog.d(TAG, &quot;Error: &quot; + error.getMessage());</div><div class="line">             &#125;</div><div class="line">        &#125;);</div><div class="line">mRequestQueue.add(jsonObjReq, tag_json_obj);</div></pre></td></tr></table></figure>
<p>我们从源码分析JsonObjectRequest.java文件，JsonObjectRequest继承Response.java，就是一个结构体，里面包含了url，请求方式，onResponse和errorResponse回调。</p>
<p>4.3 创建String请求<br>volley中有StringRequest类，用来请求string类型的数据，使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">StringRequest strReq = new StringRequest(Method.GET,</div><div class="line">            url, new Response.Listener&lt;String&gt;() &#123;</div><div class="line">                @Override</div><div class="line">                public void onResponse(String response) &#123;</div><div class="line">                    Log.d(TAG, response.toString());</div><div class="line">                    pDialog.hide();</div><div class="line">                &#125;</div><div class="line">            &#125;, new Response.ErrorListener() &#123;</div><div class="line">                @Override</div><div class="line">                public void onErrorResponse(VolleyError error) &#123;</div><div class="line">                    VolleyLog.d(TAG, &quot;Error: &quot; + error.getMessage());</div><div class="line">                    pDialog.hide();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">mRequestQueue.add(strReq, tag_json_obj);</div></pre></td></tr></table></figure>
<p>StringRequest.java跟JsonRequest结构一样。</p>
<p>4.4 创建POST请求<br>上面都是GET请求，下面是POST请求，需要将请求类型改为POST类型，并且override Request中的getParams方法就可以了，使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">JsonObjectRequest jsonObjReq = new JsonObjectRequest(Method.POST,</div><div class="line">            url, null,</div><div class="line">            new Response.Listener&lt;JSONObject&gt;() &#123;</div><div class="line">                @Override</div><div class="line">                public void onResponse(JSONObject response) &#123;</div><div class="line">                    Log.d(TAG, response.toString());</div><div class="line">                    pDialog.hide();</div><div class="line">                &#125;</div><div class="line">            &#125;, new Response.ErrorListener() &#123;</div><div class="line">                @Override</div><div class="line">                public void onErrorResponse(VolleyError error) &#123;</div><div class="line">                    VolleyLog.d(TAG, &quot;Error: &quot; + error.getMessage());</div><div class="line">                    pDialog.hide();</div><div class="line">                &#125;</div><div class="line">            &#125;) &#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        protected Map&lt;String, String&gt; getParams() &#123;</div><div class="line">            Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();</div><div class="line">            params.put(&quot;name&quot;, &quot;Androidhive&quot;);</div><div class="line">            params.put(&quot;email&quot;, &quot;abc@androidhive.info&quot;);</div><div class="line">            params.put(&quot;password&quot;, &quot;password123&quot;);</div><div class="line">            return params;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>这里通过重写Request.java中的getParams方法，将POST中的参数传入到request中，类型是Map<string, string="">。</string,></p>
<p>4.5 添加头部信息<br>override Request中的getHeaders方法就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">JsonObjectRequest jsonObjReq = new JsonObjectRequest(Method.POST,url, null,new Response.Listener&lt;JSONObject&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public void onResponse(JSONObject response) &#123;</div><div class="line">        Log.d(TAG, response.toString());</div><div class="line">        pDialog.hide();</div><div class="line">    &#125;</div><div class="line">&#125;, new Response.ErrorListener() &#123;</div><div class="line">    @Override</div><div class="line">    public void onErrorResponse(VolleyError error) &#123;</div><div class="line">        VolleyLog.d(TAG, &quot;Error: &quot; + error.getMessage());</div><div class="line">        pDialog.hide();</div><div class="line">    &#125;</div><div class="line">&#125;) &#123;</div><div class="line"></div><div class="line">@Override</div><div class="line">public Map&lt;String, String&gt; getHeaders() throws AuthFailureError &#123;</div><div class="line">    HashMap&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;();</div><div class="line">    headers.put(&quot;Content-Type&quot;, &quot;application/json&quot;);</div><div class="line">    headers.put(&quot;apiKey&quot;, &quot;xxxxxxxxxxxxxxx&quot;);</div><div class="line">    return headers;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里通过重写Request.java中的getHeaders方法，将POST中的参数传入到request中，类型是Map<string, string="">。</string,></p>
<p>4.7 Volley中的Cache机制<br>1）从请求cache中加载请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Cache=mRequestQueue.getCache();</div><div class="line">Entry entry = cache.get(url);</div><div class="line">if(entry != null)&#123;</div><div class="line">    try &#123;</div><div class="line">        String data = new String(entry.data, &quot;UTF-8&quot;);</div><div class="line">    &#125; catch (UnsupportedEncodingException e) &#123;      </div><div class="line">        e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;else&#123;</div><div class="line">    // Cached response doesn&apos;t exists. Make network call here</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2）请求缓存失效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mRequestQueue.getCache().invalidate(url, true);</div></pre></td></tr></table></figure>
<p>3）关闭cache</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringRequest stringReq = new StringRequest(....);</div><div class="line">stringReq.setShouldCache(false);//true就是打开cache</div></pre></td></tr></table></figure>
<p>4）将URL的cache删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mRequestQueue.getCache().remove(url);</div></pre></td></tr></table></figure>
<p>5）删除所有cache</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mRequestQueue.getCache().clear();</div></pre></td></tr></table></figure>
<p>4.8 请求优先级<br>优先级分为：Normal, Low, Immediate, High</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">private Priority priority = Priority.HIGH;</div><div class="line">StringRequest strReq = new StringRequest(Method.GET,</div><div class="line">            Const.URL_STRING_REQ, new Response.Listener&lt;String&gt;() &#123;</div><div class="line">                @Override</div><div class="line">                public void onResponse(String response) &#123;</div><div class="line">                    Log.d(TAG, response.toString());</div><div class="line">                    msgResponse.setText(response.toString());</div><div class="line">                    hideProgressDialog();</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;, new Response.ErrorListener() &#123;</div><div class="line">                @Override</div><div class="line">                public void onErrorResponse(VolleyError error) &#123;</div><div class="line">                    VolleyLog.d(TAG, &quot;Error: &quot; + error.getMessage());</div><div class="line">                    hideProgressDialog();</div><div class="line">                &#125;</div><div class="line">            &#125;) &#123;</div><div class="line">        @Override</div><div class="line">        public Priority getPriority() &#123;</div><div class="line">            return priority;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>4.9 取消请求<br>addToRequestQueue(request, tag)方法还接受一个tag参数，这个tag就是用来标记某一类请求的，这样就可以取消这个tag的所有请求了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mRequestQueue.cancelAll(&quot;feed_request&quot;);</div></pre></td></tr></table></figure>
<p>4.10 RequestQueue的start方法<br>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void start() &#123;</div><div class="line">        stop();  // Make sure any currently running dispatchers are stopped.</div><div class="line">        // Create the cache dispatcher and start it.</div><div class="line">        mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class="line">        mCacheDispatcher.start();</div><div class="line"></div><div class="line">        // Create network dispatchers (and corresponding threads) up to the pool size.</div><div class="line">        for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</div><div class="line">            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class="line">                    mCache, mDelivery);</div><div class="line">            mDispatchers[i] = networkDispatcher;</div><div class="line">            networkDispatcher.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>CacheDispatcher是缓存分发器，只有一个，NetworkDispatcher是网络分发器，有多个，然后我再去看一下CacheDispatcher分发器中的start方法，CacheDispatcher继承的Thread，所以直接看run方法，代码如下（注释我写在代码上面）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">public void run() &#123;</div><div class="line">        if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);</div><div class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line"></div><div class="line">        // Make a blocking call to initialize the cache.</div><div class="line">        mCache.initialize();</div><div class="line"></div><div class="line">        while (true) &#123;</div><div class="line">            try &#123;               </div><div class="line">                final Request&lt;?&gt; request = mCacheQueue.take();</div><div class="line">                request.addMarker(&quot;cache-queue-take&quot;);</div><div class="line">                </div><div class="line">                if (request.isCanceled()) &#123;</div><div class="line">                    request.finish(&quot;cache-discard-canceled&quot;);</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Attempt to retrieve this item from cache.</div><div class="line">                //尝试从缓存中获取响应结果</div><div class="line">                Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class="line">                //如果缓存中获取结果为空的话,就把这个请求放到网络请求队列中</div><div class="line">                if (entry == null) &#123;</div><div class="line">                    request.addMarker(&quot;cache-miss&quot;);</div><div class="line">                    // Cache miss; send off to the network dispatcher.</div><div class="line">                    mNetworkQueue.put(request);</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                //如果缓冲结果不为空的话,判断缓存是否过期</div><div class="line">                //如果过期的话,将这个请求放到网络请求队列中.</div><div class="line">                if (entry.isExpired()) &#123;</div><div class="line">                    request.addMarker(&quot;cache-hit-expired&quot;);</div><div class="line">                    request.setCacheEntry(entry);</div><div class="line">                    mNetworkQueue.put(request);</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                //直接使用缓存中的数据</div><div class="line">                request.addMarker(&quot;cache-hit&quot;);</div><div class="line">                //parseNetworkResponse对数据进行解析</div><div class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class="line">                        new NetworkResponse(entry.data, entry.responseHeaders));</div><div class="line">                request.addMarker(&quot;cache-hit-parsed&quot;);</div><div class="line"></div><div class="line">                //将解析出来的数据进行回调.</div><div class="line">                if (!entry.refreshNeeded()) &#123;</div><div class="line">                    // Completely unexpired cache hit. Just deliver the response.</div><div class="line">                    mDelivery.postResponse(request, response);</div><div class="line">                &#125; else &#123;</div><div class="line">                    request.addMarker(&quot;cache-hit-refresh-needed&quot;);</div><div class="line">                    request.setCacheEntry(entry);</div><div class="line">                    response.intermediate = true;</div><div class="line">                    </div><div class="line">                    mDelivery.postResponse(request, response, new Runnable() &#123;</div><div class="line">                        @Override</div><div class="line">                        public void run() &#123;</div><div class="line">                            try &#123;</div><div class="line">                                mNetworkQueue.put(request);</div><div class="line">                            &#125; catch (InterruptedException e) &#123;</div><div class="line">                                // Not much we can do about this.</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125; catch (InterruptedException e) &#123;                </div><div class="line">                if (mQuit) &#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>其中cache结构体中的内容，如上面介绍的cache机制的方法向cache中添加信息和内容。<br>同理，networkDispatcher中run方法源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public void run() &#123;</div><div class="line">       Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">       while (true) &#123;</div><div class="line">           long startTimeMs = SystemClock.elapsedRealtime();</div><div class="line">           Request&lt;?&gt; request;</div><div class="line">           try &#123;</div><div class="line">               request = mQueue.take();</div><div class="line">           &#125; catch (InterruptedException e) &#123;</div><div class="line">               if (mQuit) &#123;</div><div class="line">                   return;</div><div class="line">               &#125;</div><div class="line">               continue;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           try &#123;</div><div class="line">               request.addMarker(&quot;network-queue-take&quot;);</div><div class="line">               if (request.isCanceled()) &#123;</div><div class="line">                   request.finish(&quot;network-discard-cancelled&quot;);</div><div class="line">                   continue;</div><div class="line">               &#125;</div><div class="line">               addTrafficStatsTag(request);</div><div class="line">               //发送网络请求</div><div class="line">               NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class="line">               request.addMarker(“network-http-complete&quot;);</div><div class="line"></div><div class="line">               if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">                   request.finish(&quot;not-modified&quot;);</div><div class="line">                   continue;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">           // 在子线程中解析，在Request子类中parseNetworkResponse方法中实现解析</div><div class="line">               Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class="line">               request.addMarker(“network-parse-complete&quot;);</div><div class="line"></div><div class="line">              if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123;</div><div class="line">                   mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class="line">                   request.addMarker(&quot;network-cache-written&quot;);</div><div class="line">               &#125;</div><div class="line">               // response回调.</div><div class="line">               request.markDelivered();</div><div class="line">               mDelivery.postResponse(request, response);</div><div class="line">           &#125; catch (VolleyError volleyError) &#123;</div><div class="line">               volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class="line">               parseAndDeliverNetworkError(request, volleyError);</div><div class="line">           &#125; catch (Exception e) &#123;</div><div class="line">               VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());</div><div class="line">               VolleyError volleyError = new VolleyError(e);</div><div class="line">               volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class="line">               mDelivery.postError(request, volleyError);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>代码比较多，但是真正网络请求的核心代码应该是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NetworkResponse networkResponse = mNetwork.performRequest(request);</div></pre></td></tr></table></figure>
<p>最核心的是performRequest方法，具体代码分析我放到下一章节。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/27/Volley源码解析(一)/" data-id="ciw6kx7o1000900ug1j4hmcti" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/volley/">volley</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存/">内存</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/框架/">框架</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计/">设计</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/07/02/Volley源码解析(二)/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Volley源码解析(二)
        
      </div>
    </a>
  
  
    <a href="/2016/06/06/image-loader/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">ImageLoader源码解析</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Weapp/">Weapp</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/annotations/">annotations</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/app/">app</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/camera/">camera</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dp/">dp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/glide/">glide</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gridview/">gridview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/inflater/">inflater</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/layout/">layout</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/native/">native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/picasso/">picasso</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/support/">support</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/touch/">touch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/view/">view</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/viewgroup/">viewgroup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/volley/">volley</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/weChat/">weChat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webview/">webview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存/">内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数/">函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图片/">图片</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/对象/">对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/布局/">布局</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/支付宝/">支付宝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/框架/">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程/">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/缓存/">缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自定义/">自定义</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计/">设计</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/annotations/" style="font-size: 10px;">annotations</a> <a href="/tags/app/" style="font-size: 10px;">app</a> <a href="/tags/camera/" style="font-size: 12.5px;">camera</a> <a href="/tags/dp/" style="font-size: 10px;">dp</a> <a href="/tags/glide/" style="font-size: 12.5px;">glide</a> <a href="/tags/gridview/" style="font-size: 10px;">gridview</a> <a href="/tags/inflater/" style="font-size: 10px;">inflater</a> <a href="/tags/layout/" style="font-size: 10px;">layout</a> <a href="/tags/native/" style="font-size: 12.5px;">native</a> <a href="/tags/picasso/" style="font-size: 10px;">picasso</a> <a href="/tags/support/" style="font-size: 10px;">support</a> <a href="/tags/touch/" style="font-size: 12.5px;">touch</a> <a href="/tags/view/" style="font-size: 12.5px;">view</a> <a href="/tags/viewgroup/" style="font-size: 10px;">viewgroup</a> <a href="/tags/volley/" style="font-size: 15px;">volley</a> <a href="/tags/weChat/" style="font-size: 10px;">weChat</a> <a href="/tags/webview/" style="font-size: 10px;">webview</a> <a href="/tags/内存/" style="font-size: 10px;">内存</a> <a href="/tags/函数/" style="font-size: 10px;">函数</a> <a href="/tags/图片/" style="font-size: 10px;">图片</a> <a href="/tags/对象/" style="font-size: 10px;">对象</a> <a href="/tags/布局/" style="font-size: 12.5px;">布局</a> <a href="/tags/支付宝/" style="font-size: 10px;">支付宝</a> <a href="/tags/框架/" style="font-size: 10px;">框架</a> <a href="/tags/源码/" style="font-size: 17.5px;">源码</a> <a href="/tags/线程/" style="font-size: 10px;">线程</a> <a href="/tags/缓存/" style="font-size: 12.5px;">缓存</a> <a href="/tags/网络/" style="font-size: 10px;">网络</a> <a href="/tags/自定义/" style="font-size: 10px;">自定义</a> <a href="/tags/设计/" style="font-size: 10px;">设计</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/12/01/基于ReactNative和Realm的开源项目/">自定义相机遇到的坑总结</a>
          </li>
        
          <li>
            <a href="/2016/12/01/自定义相机踩过的坑/">自定义相机踩过的坑</a>
          </li>
        
          <li>
            <a href="/2016/09/26/微信小程序学习资料汇总/">微信小程序学习资料汇总</a>
          </li>
        
          <li>
            <a href="/2016/09/26/一个自定义的GridLayout/">一个自定义的GridLayout</a>
          </li>
        
          <li>
            <a href="/2016/09/13/LayoutInflater原理解析/">深入了解View（一）——LayoutInflater原理分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>
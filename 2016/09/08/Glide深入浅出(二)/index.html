<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Glide深入浅出（二）——源码解析 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="我们先来看看glide最基本使用方式，如下：
123456Glide.with(this)                .asDrawable()                .load(&amp;quot;http://i6.topit.me/6/5d/45/1131907198420455d6o.jpg&amp;quot;)                .apply(fitCenterTransform">
<meta property="og:type" content="article">
<meta property="og:title" content="Glide深入浅出（二）——源码解析">
<meta property="og:url" content="http://yoursite.com/2016/09/08/Glide深入浅出(二)/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="我们先来看看glide最基本使用方式，如下：
123456Glide.with(this)                .asDrawable()                .load(&amp;quot;http://i6.topit.me/6/5d/45/1131907198420455d6o.jpg&amp;quot;)                .apply(fitCenterTransform">
<meta property="og:updated_time" content="2016-11-30T23:07:34.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Glide深入浅出（二）——源码解析">
<meta name="twitter:description" content="我们先来看看glide最基本使用方式，如下：
123456Glide.with(this)                .asDrawable()                .load(&amp;quot;http://i6.topit.me/6/5d/45/1131907198420455d6o.jpg&amp;quot;)                .apply(fitCenterTransform">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Glide深入浅出(二)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/08/Glide深入浅出(二)/" class="article-date">
  <time datetime="2016-09-08T11:19:18.000Z" itemprop="datePublished">2016-09-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Glide深入浅出（二）——源码解析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们先来看看glide最基本使用方式，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Glide.with(this)</div><div class="line">                .asDrawable()</div><div class="line">                .load(&quot;http://i6.topit.me/6/5d/45/1131907198420455d6o.jpg&quot;)</div><div class="line">                .apply(fitCenterTransform(this))</div><div class="line">                .apply(placeholderOf(R.drawable.skyblue_logo_wechatfavorite_checked))</div><div class="line">                .into(imageView);</div></pre></td></tr></table></figure>
<p>本片文章就从这个最简单的使用方法来对源码进行一波解析。</p>
<h2 id="一、大概介绍"><a href="#一、大概介绍" class="headerlink" title="一、大概介绍"></a>一、大概介绍</h2><p><strong>Glide.java 入口文件</strong></p>
<p>这里其实就是一个入口文件，所有功能都是放在后面的类中，这里所有需要的组件都在这个文件里面进行统一初始化。</p>
<p><strong>RequestManager.java</strong></p>
<p>这个类主要是用于管理和启动glide的所有请求，可以使用activity，fragment或者连接生命周期的事件去只能的停止，启动和重启请求。也可以检索或者通过实例化一个新的对象，或者使用静态的glide去利用构建在activity和fragment生命周期处理中。它的方法跟你的fragment和activity是同步的。</p>
<p><strong>RequestBuilder.java</strong></p>
<p>可以处理设置选项，并启动负载的通用资源类型。</p>
<p>看前面的例子代码中，asDrawable()最终调用的的RequestBuilder中的transition()函数，这个方法主要是用于加载对象从占位符(placeholder)或者缩略图(thumbnail)到真正对象加载完成的专场动画。</p>
<p>load()方法中，这里可以加载很多类型的数据对象，可以是string，uri，file，resourceId，byte[]这些。对应的编码方式也是不一样的。</p>
<p>into()方法，是真正启动加载的地方。</p>
<h2 id="二、具体源码解析"><a href="#二、具体源码解析" class="headerlink" title="二、具体源码解析"></a>二、具体源码解析</h2><p><strong>Glide.with()函数</strong></p>
<p>先看一下glide中的with函数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static RequestManager with(Activity activity) &#123;</div><div class="line">  RequestManagerRetriever retriever = RequestManagerRetriever.get();</div><div class="line">  return retriever.get(activity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里返回的是RequestManagerRetriever.get()，我们看一下这个函数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@TargetApi(Build.VERSION_CODES.HONEYCOMB)</div><div class="line">  public RequestManager get(Activity activity) &#123;</div><div class="line">    if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">      return get(activity.getApplicationContext());</div><div class="line">    &#125; else &#123;</div><div class="line">      assertNotDestroyed(activity);</div><div class="line">      android.app.FragmentManager fm = activity.getFragmentManager();</div><div class="line">      return fragmentGet(activity, fm, null);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>（当然这个with()可以传很多类型进来，我们只看activity的情况）<br>源码中，如果该activity在后台的时候，我们进入get(Application)中，继续我们刚刚说的这个步骤来。<br>所以我们就直接看fragmentGet(activity, fm, null)函数，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@TargetApi(Build.VERSION_CODES.HONEYCOMB)</div><div class="line">  RequestManager fragmentGet(Context context, android.app.FragmentManager fm,</div><div class="line">      android.app.Fragment parentHint) &#123;</div><div class="line">    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);</div><div class="line">    RequestManager requestManager = current.getRequestManager();</div><div class="line">    if (requestManager == null) &#123;</div><div class="line">      // TODO(b/27524013): Factor out this Glide.get() call.</div><div class="line">      Glide glide = Glide.get(context);</div><div class="line">      requestManager =</div><div class="line">          new RequestManager(glide, current.getLifecycle(), current.getRequestManagerTreeNode());</div><div class="line">      current.setRequestManager(requestManager);</div><div class="line">    &#125;</div><div class="line">    return requestManager;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这个函数作用正如它的名字一样，就是获取fragment，其实是返回的RequestManager，那这个到底是啥？看一下getRequestManagerFragment函数，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)</div><div class="line">RequestManagerFragment getRequestManagerFragment(</div><div class="line">    final android.app.FragmentManager fm, android.app.Fragment parentHint) &#123;</div><div class="line">  RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</div><div class="line">  if (current == null) &#123;</div><div class="line">    current = pendingRequestManagerFragments.get(fm);</div><div class="line">    if (current == null) &#123;</div><div class="line">      current = new RequestManagerFragment();</div><div class="line">      current.setParentFragmentHint(parentHint);</div><div class="line">      pendingRequestManagerFragments.put(fm, current);</div><div class="line">      fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</div><div class="line">      handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return current;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（其中传进来的参数fm，是我们获取的activity的FragmentManager）<br>这里其实就是就是将我们传进来的activity转化为glide需要的RequestManagerFragment，RequestManagerFragment是一个自己重新以的fragment而已。</p>
<p><strong>asDrawable函数</strong></p>
<p>源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public RequestBuilder&lt;Drawable&gt; asDrawable() &#123;</div><div class="line">  return as(Drawable.class).transition(new DrawableTransitionOptions());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>添加一个DrawableTransitionOptions类型的动画。</p>
<p><strong>load函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public RequestBuilder&lt;Drawable&gt; load(@Nullable Object model) &#123;</div><div class="line">    return asDrawable().load(model);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">public RequestBuilder&lt;TranscodeType&gt; load(@Nullable Object model) &#123;</div><div class="line">    return loadGeneric(model);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private RequestBuilder&lt;TranscodeType&gt; loadGeneric(@Nullable Object model) &#123;</div><div class="line">    this.model = model;</div><div class="line">    isModelSet = true;</div><div class="line">    return this;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>将你要传递的uri，file等等传进来，放到RequestBuilder中。</p>
<p><strong>into函数</strong></p>
<p>最终我们都要调用这个into了，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public Target&lt;TranscodeType&gt; into(ImageView view) &#123;</div><div class="line">    Util.assertMainThread();</div><div class="line">    Preconditions.checkNotNull(view);</div><div class="line"></div><div class="line">    if (!requestOptions.isTransformationSet()</div><div class="line">        &amp;&amp; requestOptions.isTransformationAllowed()</div><div class="line">        &amp;&amp; view.getScaleType() != null) &#123;</div><div class="line">      if (requestOptions.isLocked()) &#123;</div><div class="line">        requestOptions = requestOptions.clone();</div><div class="line">      &#125;</div><div class="line">      switch (view.getScaleType()) &#123;</div><div class="line">        case CENTER_CROP:</div><div class="line">          requestOptions.optionalCenterCrop(context);</div><div class="line">          break;</div><div class="line">        case CENTER_INSIDE:</div><div class="line">          requestOptions.optionalCenterInside(context);</div><div class="line">          break;</div><div class="line">        case FIT_CENTER:</div><div class="line">        case FIT_START:</div><div class="line">        case FIT_END:</div><div class="line">          requestOptions.optionalFitCenter(context);</div><div class="line">          break;</div><div class="line">        //$CASES-OMITTED$</div><div class="line">        default:</div><div class="line">          // Do nothing.</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return into(context.buildImageViewTarget(view, transcodeClass));</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这里针对ImageView的填充方式做了筛选并对应设置到requestOptions上。最终的是通过ImageView和转码类型（transcodeClass）创建不通过的Target（例如Bitmap对应的BitmapImageViewTarget和Drawable对应的DrawableImageViewTarget）。<br>到这里，我们看到的源码，并没有涉及到解码、缓存、加载等这些功能啊，是不是我们漏掉一些重要的函数？没错，我们的确漏掉一个很重要的函数，在into函数中，有一行代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">requestManager.track(target, request);</div></pre></td></tr></table></figure>
<p>这个就是最核心的方法，它才是真正触发请求、编解码、装载、缓存等这些功能的。下面我详细介绍一下。</p>
<p><strong>track()函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void track(Target&lt;?&gt; target, Request request) &#123;</div><div class="line">    targetTracker.track(target);</div><div class="line">    requestTracker.runRequest(request);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>第一行，就是把target加入targets队列（WeakHashMap）中。<br>看一下runRequest函数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void runRequest(Request request) &#123;</div><div class="line">   requests.add(request);//添加到内存缓存</div><div class="line">   if (!isPaused) &#123;</div><div class="line">     request.begin();//开始</div><div class="line">   &#125; else &#123;</div><div class="line">     pendingRequests.add(request);//挂起请求</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>然后看一下request.begin()是如何运作的，SingleRequest继承一个抽象类，定义了begin方法，所以我们看一下SingleRequest中begin方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">  public void begin() &#123;</div><div class="line">    stateVerifier.throwIfRecycled();</div><div class="line">    startTime = LogTime.getLogTime();</div><div class="line">    // 如果model空的，那么是不能执行的。 这里的model就是前面提到的RequestBuilder中的model</div><div class="line">    if (model == null) &#123;</div><div class="line">      if (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</div><div class="line">        width = overrideWidth;</div><div class="line">        height = overrideHeight;</div><div class="line">      &#125;</div><div class="line">      // Only log at more verbose log levels if the user has set a fallback drawable, because</div><div class="line">      // fallback Drawables indicate the user expects null models occasionally.</div><div class="line">      int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG;</div><div class="line">      onLoadFailed(new GlideException(&quot;Received null model&quot;), logLevel);</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line">    status = Status.WAITING_FOR_SIZE;</div><div class="line">    //如果当前的View尺寸获取到了，就会进入加载流程</div><div class="line">    if (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</div><div class="line">      onSizeReady(overrideWidth, overrideHeight);</div><div class="line">    &#125; else &#123;</div><div class="line">      target.getSize(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//如果等待和正在执行状态，那么当前会加载占位符Drawable</div><div class="line">    if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</div><div class="line">        &amp;&amp; canNotifyStatusChanged()) &#123;</div><div class="line">      target.onLoadStarted(getPlaceholderDrawable());</div><div class="line">    &#125;</div><div class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">      logV(&quot;finished run method in &quot; + LogTime.getElapsedMillis(startTime));</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>看上面注释，如果，当前view尺寸还没有获取到，我们要执行target.getSize(this)函数，我们看一下这个函数实现方法(ViewTarget实现的)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">void getSize(SizeReadyCallback cb) &#123;</div><div class="line">      int currentWidth = getViewWidthOrParam();</div><div class="line">      int currentHeight = getViewHeightOrParam();</div><div class="line">      if (isSizeValid(currentWidth) &amp;&amp; isSizeValid(currentHeight)) &#123;</div><div class="line">        int paddingAdjustedWidth = currentWidth == WindowManager.LayoutParams.WRAP_CONTENT</div><div class="line">            ? currentWidth</div><div class="line">            : currentWidth - ViewCompat.getPaddingStart(view) - ViewCompat.getPaddingEnd(view);</div><div class="line">        int paddingAdjustedHeight = currentHeight == LayoutParams.WRAP_CONTENT</div><div class="line">            ? currentHeight</div><div class="line">            : currentHeight - view.getPaddingTop() - view.getPaddingBottom();</div><div class="line">        cb.onSizeReady(paddingAdjustedWidth, paddingAdjustedHeight);</div><div class="line">      &#125; else &#123;</div><div class="line">        // We want to notify callbacks in the order they were added and we only expect one or two</div><div class="line">        // callbacks to</div><div class="line">        // be added a time, so a List is a reasonable choice.</div><div class="line">        if (!cbs.contains(cb)) &#123;</div><div class="line">          cbs.add(cb);</div><div class="line">        &#125;</div><div class="line">        if (layoutListener == null) &#123;</div><div class="line">        //这是尺寸大小的监听器</div><div class="line">          final ViewTreeObserver observer = view.getViewTreeObserver();          </div><div class="line">          layoutListener = new SizeDeterminerLayoutListener(this);</div><div class="line">          observer.addOnPreDrawListener(layoutListener);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里加了ViewTreeObserver用来监听view尺寸大小，我们可以看看SizeDeterminerLayoutListener做了什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private static class SizeDeterminerLayoutListener implements ViewTreeObserver</div><div class="line">        .OnPreDrawListener &#123;</div><div class="line">      private final WeakReference&lt;SizeDeterminer&gt; sizeDeterminerRef;</div><div class="line"></div><div class="line">      public SizeDeterminerLayoutListener(SizeDeterminer sizeDeterminer) &#123;</div><div class="line">        sizeDeterminerRef = new WeakReference&lt;&gt;(sizeDeterminer);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override</div><div class="line">      public boolean onPreDraw() &#123;</div><div class="line">        if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">          Log.v(TAG, &quot;OnGlobalLayoutListener called listener=&quot; + this);</div><div class="line">        &#125;</div><div class="line">        SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();</div><div class="line">        if (sizeDeterminer != null) &#123;</div><div class="line">        // 通知SizeDeterminer去重新检查尺寸，并触发后续操作。</div><div class="line">          sizeDeterminer.checkCurrentDimens();</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>看完这个getsize，我们再返回到上面begin中的onSizeReady(overrideWidth, overrideHeight)函数，这个才是真正加载的函数。主要是engine发起的load操作，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">  public void onSizeReady(int width, int height) &#123;</div><div class="line">    stateVerifier.throwIfRecycled();</div><div class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">      logV(&quot;Got onSizeReady in &quot; + LogTime.getElapsedMillis(startTime));</div><div class="line">    &#125;</div><div class="line">    if (status != Status.WAITING_FOR_SIZE) &#123;</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line">    status = Status.RUNNING;</div><div class="line"></div><div class="line">    float sizeMultiplier = requestOptions.getSizeMultiplier();</div><div class="line">    this.width = maybeApplySizeMultiplier(width, sizeMultiplier);</div><div class="line">    this.height = maybeApplySizeMultiplier(height, sizeMultiplier);</div><div class="line"></div><div class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">      logV(&quot;finished setup for calling load in &quot; + LogTime.getElapsedMillis(startTime));</div><div class="line">    &#125;</div><div class="line">    loadStatus = engine.load(</div><div class="line">        glideContext,</div><div class="line">        model,</div><div class="line">        requestOptions.getSignature(),</div><div class="line">        this.width,</div><div class="line">        this.height,</div><div class="line">        requestOptions.getResourceClass(),</div><div class="line">        transcodeClass,</div><div class="line">        priority,</div><div class="line">        requestOptions.getDiskCacheStrategy(),</div><div class="line">        requestOptions.getTransformations(),</div><div class="line">        requestOptions.isTransformationRequired(),</div><div class="line">        requestOptions.getOptions(),</div><div class="line">        requestOptions.isMemoryCacheable(),</div><div class="line">        requestOptions.getUseUnlimitedSourceGeneratorsPool(),</div><div class="line">        this);</div><div class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">      logV(&quot;finished onSizeReady in &quot; + LogTime.getElapsedMillis(startTime));</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>那么这个engine从哪里来的呢？它在glide初始化的时候，就创建了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (engine == null) &#123;</div><div class="line">      engine = new Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>包括参数内存缓存和磁盘缓存。然后我们看一下load具体实现，这里代码比较多，所以我就挑了几个重要的看了一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">//给每次加载资源创建一个key，作为唯一的标识。</div><div class="line">    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</div><div class="line">        resourceClass, transcodeClass, options);</div><div class="line"></div><div class="line">//通过key load缓存资源，这是一级内存缓存，是从内存缓存中直接拿出来的</div><div class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</div><div class="line">    if (cached != null) &#123;</div><div class="line">         cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</div><div class="line">      if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">        logWithTimeAndKey(&quot;Loaded resource from cache&quot;, startTime, key);</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//这里是二级内存缓存，使用Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt;保存起来的</div><div class="line">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</div><div class="line">    if (active != null) &#123;</div><div class="line">      cb.onResourceReady(active, DataSource.MEMORY_CACHE);</div><div class="line">      if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">        logWithTimeAndKey(&quot;Loaded resource from active resources&quot;, startTime, key);</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//根据key获取缓存的任务</div><div class="line">    EngineJob&lt;?&gt; current = jobs.get(key);</div><div class="line">    if (current != null) &#123;</div><div class="line">      current.addCallback(cb);</div><div class="line">      if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">        logWithTimeAndKey(&quot;Added to existing load&quot;, startTime, key);</div><div class="line">      &#125;</div><div class="line">      return new LoadStatus(cb, current);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//创建任务</div><div class="line">    EngineJob&lt;R&gt; engineJob = engineJobFactory.build(key, isMemoryCacheable,</div><div class="line">        useUnlimitedSourceExecutorPool);</div><div class="line">    DecodeJob&lt;R&gt; decodeJob = decodeJobFactory.build(</div><div class="line">        glideContext,</div><div class="line">        model,</div><div class="line">        key,</div><div class="line">        signature,</div><div class="line">        width,</div><div class="line">        height,</div><div class="line">        resourceClass,</div><div class="line">        transcodeClass,</div><div class="line">        priority,</div><div class="line">        diskCacheStrategy,</div><div class="line">        transformations,</div><div class="line">        isTransformationRequired,</div><div class="line">        options,</div><div class="line">        engineJob);</div><div class="line">    jobs.put(key, engineJob);</div><div class="line">    engineJob.addCallback(cb);</div><div class="line">    //放入线程池，执行</div><div class="line">    engineJob.start(decodeJob);</div><div class="line"></div><div class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">      logWithTimeAndKey(&quot;Started new load&quot;, startTime, key);</div><div class="line">    &#125;</div><div class="line">    return new LoadStatus(cb, engineJob);</div></pre></td></tr></table></figure>
<p>还有一个问题，这个二级缓存，是谁放入二级内存中呢，我们看一下上面一级缓存的loadFromCache方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private EngineResource&lt;?&gt; loadFromCache(Key key, boolean isMemoryCacheable) &#123;</div><div class="line">   if (!isMemoryCacheable) &#123;</div><div class="line">     return null;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</div><div class="line">   if (cached != null) &#123;</div><div class="line">     cached.acquire();</div><div class="line">     activeResources.put(key, new ResourceWeakReference(key, cached, getReferenceQueue()));</div><div class="line">   &#125;</div><div class="line">   return cached;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这里把带有key的缓存存到activeResources中，二级缓存中loadFromActiveResources函数，也是从activeResources中拿到资源，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private EngineResource&lt;?&gt; loadFromActiveResources(Key key, boolean isMemoryCacheable) &#123;</div><div class="line">  if (!isMemoryCacheable) &#123;</div><div class="line">    return null;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  EngineResource&lt;?&gt; active = null;</div><div class="line">  //从activeResources中拿到key的cache</div><div class="line">  WeakReference&lt;EngineResource&lt;?&gt;&gt; activeRef = activeResources.get(key);</div><div class="line">  if (activeRef != null) &#123;</div><div class="line">    active = activeRef.get();</div><div class="line">    if (active != null) &#123;</div><div class="line">      active.acquire();</div><div class="line">    &#125; else &#123;</div><div class="line">      activeResources.remove(key);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return active;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除此之外呢?<br>1、一级内存缓存，glide中默认的就是我们常用的LruResourceCache。<br>2、我们说glide是加载imageview，我们从哪里知道的呢，还记得使用的时候into()函数中我们传入的是imageview，而我们源码中的target就是我们传进来的imageview。在track函数中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void track(Target&lt;?&gt; target) &#123;</div><div class="line">   targets.add(target);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>我们将target也就是我们的imageview加入到缓存中去了。<br>3、为何要两级内存缓存（loadFromActiveResources）。从资料上看猜测可能是一级缓存采用LRU算法进行缓存，不一定每个都能缓存到，添加二级缓存 可以保证每个都能缓存到；<br>4、EngineJob和DecodeJob各自职责：EngineJob充当了管理和调度者，主要负责加载和各类回调通知；DecodeJob是真正干活的劳动者，这个类实现了Runnable接口。</p>
<p>那我们来看一下真正线程(DecodeJob)里面是怎么执行的？<br>我怕大家忘了engine.load的代码，所以我先把使用EngineJob和DecodeJob的代码贴在下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//创建任务</div><div class="line">    EngineJob&lt;R&gt; engineJob = engineJobFactory.build(key, isMemoryCacheable,</div><div class="line">        useUnlimitedSourceExecutorPool);</div><div class="line">    DecodeJob&lt;R&gt; decodeJob = decodeJobFactory.build(</div><div class="line">        glideContext,</div><div class="line">        model,</div><div class="line">        key,</div><div class="line">        signature,</div><div class="line">        width,</div><div class="line">        height,</div><div class="line">        resourceClass,</div><div class="line">        transcodeClass,</div><div class="line">        priority,</div><div class="line">        diskCacheStrategy,</div><div class="line">        transformations,</div><div class="line">        isTransformationRequired,</div><div class="line">        options,</div><div class="line">        engineJob);</div><div class="line">    jobs.put(key, engineJob);</div><div class="line">    engineJob.addCallback(cb);</div><div class="line">    //放入线程池，执行</div><div class="line">    engineJob.start(decodeJob);</div><div class="line"></div><div class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">      logWithTimeAndKey(&quot;Started new load&quot;, startTime, key);</div><div class="line">    &#125;</div><div class="line">    return new LoadStatus(cb, engineJob);</div></pre></td></tr></table></figure></p>
<p>然后我们在继续看一下DecodeJob是如何执行的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">  public void run() &#123;</div><div class="line">    // This should be much more fine grained, but since Java&apos;s thread pool implementation silently</div><div class="line">    // swallows all otherwise fatal exceptions, this will at least make it obvious to developers</div><div class="line">    // that something is failing.</div><div class="line">    try &#123;</div><div class="line">      if (isCancelled) &#123;</div><div class="line">        notifyFailed();</div><div class="line">        return;</div><div class="line">      &#125;</div><div class="line">      runWrapped();</div><div class="line">    &#125; catch (RuntimeException e) &#123;</div><div class="line">      if (Log.isLoggable(TAG, Log.DEBUG)) &#123;</div><div class="line">        Log.d(TAG, &quot;DecodeJob threw unexpectedly&quot;</div><div class="line">            + &quot;, isCancelled: &quot; + isCancelled</div><div class="line">            + &quot;, stage: &quot; + stage, e);</div><div class="line">      &#125;</div><div class="line">      // When we&apos;re encoding we&apos;ve already notified our callback and it isn&apos;t safe to do so again.</div><div class="line">      if (stage != Stage.ENCODE) &#123;</div><div class="line">        notifyFailed();</div><div class="line">      &#125;</div><div class="line">      if (!isCancelled) &#123;</div><div class="line">        throw e;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>然后在看里面的runWrapped函数，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private void runWrapped() &#123;</div><div class="line">   switch (runReason) &#123;</div><div class="line">    case INITIALIZE:</div><div class="line">    //初始化，获取下一个阶段的状态</div><div class="line">      stage = getNextStage(Stage.INITIALIZE);</div><div class="line">      currentGenerator = getNextGenerator();</div><div class="line">      //运行</div><div class="line">      runGenerators();</div><div class="line">      break;</div><div class="line">    case SWITCH_TO_SOURCE_SERVICE:</div><div class="line">      runGenerators();</div><div class="line">      break;</div><div class="line">    case DECODE_DATA:</div><div class="line">      decodeFromRetrievedData();</div><div class="line">      break;</div><div class="line">    default:</div><div class="line">      throw new IllegalStateException(&quot;Unrecognized run reason: &quot; + runReason);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先看getNextStage方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 这里的阶段策略首先是从resource中寻找，然后再是data，，再是source</div><div class="line">private Stage getNextStage(Stage current) &#123;</div><div class="line">    switch (current) &#123;</div><div class="line">      case INITIALIZE:</div><div class="line">      // 根据定义的缓存策略来回去下一个状态</div><div class="line">	  // 缓存策略来之于RequestBuilder的requestOptions域</div><div class="line">	  // 如果你有自定义的策略，可以调用RequestBuilder.apply方法即可</div><div class="line">	  // 详细的可用缓存策略请参看DiskCacheStrategy.java</div><div class="line">        return diskCacheStrategy.decodeCachedResource()</div><div class="line">            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);</div><div class="line">      case RESOURCE_CACHE:</div><div class="line">        return diskCacheStrategy.decodeCachedData()</div><div class="line">            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);</div><div class="line">      case DATA_CACHE:</div><div class="line">        return Stage.SOURCE;</div><div class="line">      case SOURCE:</div><div class="line">      case FINISHED:</div><div class="line">        return Stage.FINISHED;</div><div class="line">      default:</div><div class="line">        throw new IllegalArgumentException(&quot;Unrecognized stage: &quot; + current);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>再看getNextGenerator函数，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 根据Stage找到数据抓取生成器。</div><div class="line">private DataFetcherGenerator getNextGenerator() &#123;</div><div class="line">    switch (stage) &#123;</div><div class="line">      case RESOURCE_CACHE:</div><div class="line">       // 产生含有降低采样/转换资源数据缓存文件的DataFetcher。</div><div class="line">        return new ResourceCacheGenerator(decodeHelper, this);</div><div class="line">      case DATA_CACHE:</div><div class="line">      // 产生包含原始未修改的源数据缓存文件的DataFetcher。</div><div class="line">        return new DataCacheGenerator(decodeHelper, this);</div><div class="line">      case SOURCE:</div><div class="line">      // 生成使用注册的ModelLoader和加载时提供的Model获取源数据规定的DataFetcher。</div><div class="line">      // 根据不同的磁盘缓存策略，源数据可首先被写入到磁盘，然后从缓存文件中加载，而不是直接返回。</div><div class="line">        return new SourceGenerator(decodeHelper, this);</div><div class="line">      case FINISHED:</div><div class="line">        return null;</div><div class="line">      default:</div><div class="line">        throw new IllegalStateException(&quot;Unrecognized stage: &quot; + stage);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>经过上面的流程，最后就是发起实际请求的地方了，SourceGenerator.startNext()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">  public boolean startNext() &#123;</div><div class="line">    if (dataToCache != null) &#123;</div><div class="line">      Object data = dataToCache;</div><div class="line">      dataToCache = null;</div><div class="line">      cacheData(data);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (sourceCacheGenerator != null &amp;&amp; sourceCacheGenerator.startNext()) &#123;</div><div class="line">      return true;</div><div class="line">    &#125;</div><div class="line">    sourceCacheGenerator = null;</div><div class="line"></div><div class="line">    loadData = null;</div><div class="line">    boolean started = false;</div><div class="line">    while (!started &amp;&amp; hasNextModelLoader()) &#123;</div><div class="line">      loadData = helper.getLoadData().get(loadDataListIndex++);</div><div class="line">      if (loadData != null</div><div class="line">          &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</div><div class="line">          || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</div><div class="line">        started = true;</div><div class="line">        loadData.fetcher.loadData(helper.getPriority(), this);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    return started;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里的Model必须是实现了GlideModule接口的，fetcher是实现了DataFetcher接口。有兴趣同学可以继续看一下integration中的okhttp和volley工程。Glide主要采用了这两种网络libray来下载图片。</p>
<p>数据下载完成后缓存处理SourceGenerator.onDataReady</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"> public void onDataReady(Object data) &#123;</div><div class="line">   DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();</div><div class="line">   if (data != null &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;</div><div class="line">     dataToCache = data;</div><div class="line">     // We might be being called back on someone else&apos;s thread. Before doing anything, we should</div><div class="line">     // reschedule to get back onto Glide&apos;s thread.</div><div class="line">     cb.reschedule();</div><div class="line">   &#125; else &#123;</div><div class="line">     cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher,</div><div class="line">         loadData.fetcher.getDataSource(), originalKey);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这里将下载的data存到磁盘cache中，但是咋就一句dataToCache = data，其实是在cb.reschedule()，cb就是decodeJob。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void reschedule() &#123;</div><div class="line">    runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;</div><div class="line">    callback.reschedule(this);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里又有一个Callback，继续追踪，这里的Callback接口是定义在DecodeJob内的，而实现是在外部的Engine中（这里会用线程池重新启动当前job，那为什么要这样做呢？源码中的解释是为了不同线程的切换，因为下载都是借用第三方网络库，而实际的编解码是在Glide自定义的线程池中进行的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void reschedule(DecodeJob&lt;?&gt; job) &#123;</div><div class="line">  if (isCancelled) &#123;</div><div class="line">    MAIN_THREAD_HANDLER.obtainMessage(MSG_CANCELLED, this).sendToTarget();</div><div class="line">  &#125; else &#123;</div><div class="line">    sourceExecutor.execute(job);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来继续DecodeJob.runWrapped()方法。这个时候的runReason是SWITCH_TO_SOURCE_SERVICE，因此直接执行runGenerators()，这里继续执行SourceGenerator.startNext()方法，值得注意的dataToCache域，因为上一次执行的时候是下载，因此再次执行的时候内存缓存已经存在，因此直接缓存数据cacheData(data)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">private void cacheData(Object dataToCache) &#123;</div><div class="line">  long startTime = LogTime.getLogTime();</div><div class="line">  try &#123;</div><div class="line">    Encoder&lt;Object&gt; encoder = helper.getSourceEncoder(dataToCache);</div><div class="line">    DataCacheWriter&lt;Object&gt; writer =</div><div class="line">        new DataCacheWriter&lt;&gt;(encoder, dataToCache, helper.getOptions());</div><div class="line">    originalKey = new DataCacheKey(loadData.sourceKey, helper.getSignature());</div><div class="line">    helper.getDiskCache().put(originalKey, writer);</div><div class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">      Log.v(TAG, &quot;Finished encoding source to cache&quot;</div><div class="line">          + &quot;, key: &quot; + originalKey</div><div class="line">          + &quot;, data: &quot; + dataToCache</div><div class="line">          + &quot;, encoder: &quot; + encoder</div><div class="line">          + &quot;, duration: &quot; + LogTime.getElapsedMillis(startTime));</div><div class="line">    &#125;</div><div class="line">  &#125; finally &#123;</div><div class="line">    loadData.fetcher.cleanup();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  sourceCacheGenerator =</div><div class="line">      new DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在会到SourceGenerator.startNext()方法，这个时候已经有了sourceCacheGenerator，那么直接执行DataCacheGenerator.startNext()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"> public boolean startNext() &#123;</div><div class="line">   while (modelLoaders == null || !hasNextModelLoader()) &#123;</div><div class="line">     sourceIdIndex++;</div><div class="line">     if (sourceIdIndex &gt;= cacheKeys.size()) &#123;</div><div class="line">       return false;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     Key sourceId = cacheKeys.get(sourceIdIndex);</div><div class="line">     Key originalKey = new DataCacheKey(sourceId, helper.getSignature());</div><div class="line">     cacheFile = helper.getDiskCache().get(originalKey);</div><div class="line">     if (cacheFile != null) &#123;</div><div class="line">       this.sourceKey = sourceId;</div><div class="line">       modelLoaders = helper.getModelLoaders(cacheFile);</div><div class="line">       modelLoaderIndex = 0;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   loadData = null;</div><div class="line">   boolean started = false;</div><div class="line">   // 这里会通过model寻找注册过的ModelLoader</div><div class="line">   while (!started &amp;&amp; hasNextModelLoader()) &#123;</div><div class="line">     ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++);</div><div class="line">     loadData =</div><div class="line">         modelLoader.buildLoadData(cacheFile, helper.getWidth(), helper.getHeight(),</div><div class="line">             helper.getOptions());</div><div class="line">             // 通过FileLoader继续加载数据</div><div class="line">     if (loadData != null &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) &#123;</div><div class="line">       started = true;</div><div class="line">       loadData.fetcher.loadData(helper.getPriority(), this);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   return started;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这里的ModelLoader跟之前提到过的Register的模块加载器（ModelLoader）对应是modelLoaderRegistry域，具体执行的操作是Registry.getModelLoaders(…)方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public &lt;Model&gt; List&lt;ModelLoader&lt;Model, ?&gt;&gt; getModelLoaders(Model model) &#123;</div><div class="line">   List&lt;ModelLoader&lt;Model, ?&gt;&gt; result = modelLoaderRegistry.getModelLoaders(model);</div><div class="line">   if (result.isEmpty()) &#123;</div><div class="line">     throw new NoModelLoaderAvailableException(model);</div><div class="line">   &#125;</div><div class="line">   return result;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>继续回到DataCacheGenerator.startNext()方法，找到了ModelLoader，然后跟踪到的是FileLoader类(FileFetcher.loadData(…)方法)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public void loadData(Priority priority, DataCallback&lt;? super Data&gt; callback) &#123;</div><div class="line">	// 读取文件数据</div><div class="line">     try &#123;</div><div class="line">       data = opener.open(file);</div><div class="line">     &#125; catch (FileNotFoundException e) &#123;</div><div class="line">       if (Log.isLoggable(TAG, Log.DEBUG)) &#123;</div><div class="line">         Log.d(TAG, &quot;Failed to open file&quot;, e);</div><div class="line">       &#125;</div><div class="line">	//失败</div><div class="line">       callback.onLoadFailed(e);</div><div class="line">       return;</div><div class="line">     &#125;</div><div class="line">  // 成功</div><div class="line">     callback.onDataReady(data);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><strong>装载流程</strong></p>
<p>代码太多，实在有点绕晕了，所以就将一位大神的博客里面装载流程粘了过来。<br>主要线路如下：<br>–&gt;DataCacheGenerator.onDataReady<br>  –&gt;SourceGenerator.onDataFetcherReady<br>    –&gt;DecodeJob.onDataFetcherReady<br>    –&gt;DecodeJob.decodeFromRetrievedData<br>    –&gt;DecodeJob.notifyEncodeAndRelease<br>    –&gt;DecodeJob.notifyComplete<br>      –&gt;EngineJob.onResourceReady</p>
<p>需要说明的就是在EngineJob中有一个Handler叫MAIN_THREAD_HANDLER。为了实现在主UI中装载资源的作用，ok继续上边的流程：</p>
<p>–&gt;EngineJob.handleResultOnMainThread<br>  –&gt;SingleRequest.onResourceReady<br>    –&gt;ImageViewTarget.onResourceReady<br>    –&gt;ImageViewTarget.setResource<br>      –&gt;ImageView.setImageDrawable/ImageView.setImageBitmap</p>
<p>数据的装载过程中有一个很重要的步骤就是decode，这个操作发生在DecodeJob.decodeFromRetrievedData的时候，继续看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">private void decodeFromRetrievedData() &#123;</div><div class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</div><div class="line">      logWithTimeAndKey(&quot;Retrieved data&quot;, startFetchTime,</div><div class="line">          &quot;data: &quot; + currentData</div><div class="line">          + &quot;, cache key: &quot; + currentSourceKey</div><div class="line">          + &quot;, fetcher: &quot; + currentFetcher);</div><div class="line">    &#125;</div><div class="line">    Resource&lt;R&gt; resource = null;</div><div class="line">    try &#123;</div><div class="line">      resource = decodeFromData(currentFetcher, currentData, currentDataSource);</div><div class="line">    &#125; catch (GlideException e) &#123;</div><div class="line">      e.setLoggingDetails(currentAttemptingKey, currentDataSource);</div><div class="line">      exceptions.add(e);</div><div class="line">    &#125;</div><div class="line">    if (resource != null) &#123;</div><div class="line">      notifyEncodeAndRelease(resource, currentDataSource);</div><div class="line">    &#125; else &#123;</div><div class="line">      runGenerators();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这中间发生了很多转换主要流程：</p>
<p>–&gt;DecodeJob.decodeFromData<br>–&gt;DecodeJob.decodeFromFetcher<br>–&gt;DecodeJob.runLoadPath<br>  –&gt;LoadPath.load<br>  –&gt;LoadPath.loadWithExceptionList<br>  –&gt;LoadPath.decode<br>  –&gt;LoadPath.decodeResource<br>  –&gt;LoadPath.decodeResourceWithList<br>    –&gt;ResourceDecoder.handles<br>    –&gt;ResourceDecoder.decode</p>
<p>这里讲到了decode，那么encode发生在什么时候呢？直接通过Encoder接口调用发现，在数据缓存的时候才会触发编码。具体调用在DiskLruCacheWrapper和DataCacheWriter中。一些值得参考的写法例如BitmapEncoder对Bitmap的压缩处理。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p><strong>总结，glide库很大，自己在看源码的时候，也参考了别人对glide的理解，将glide的大概流程的主要源码看了一下，其中可能会有很多理解不对或者不足的地方，希望大家能给指出来。</strong><br>下面是是一位大神看完glide之后的结束语，个人觉得还是很不错的。</p>
<p>1、总体来说代码写的挺漂亮的，单从使用者角度来说入手是比较容易的。<br>2、源码使用了大量的工厂方法来创建对象，就像String.valueof(…)方法一样，这也体现编码的优雅。<br>3、不过想要对这个库进行改造，可能并非易事，笔者在跟踪代码的过程中发现很多地方有Callback这样的接口，来来回回查找几次很容易就晕头转向了。。。<br>另外一个感觉难受的地方就是构造方法带入参数太多，就拿SingleRequest来说就是12个构造参数。<br>4、单例的使用感觉还是有些模糊，就比如GlideContext，有些时候通过Glide.get(context).getGlideContext()获取，而有些类中采用构造传入。个人觉得既然让Glide作为单例，那么还这样传入参数是不是有点多余？代码的编写都是可以折中考虑，不过如果整个项目拟定好了一个规则的话，我想最好还是遵循它。另外再吐槽一下单例，很多开发人员喜欢用单例，如果你是有代码洁癖的开发者，那么你肯定很讨厌这样，单例很容易造成代码的散落和结构不清晰。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/08/Glide深入浅出(二)/" data-id="ciw6kx7nx000500ugcgb4owy1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/glide/">glide</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/09/13/LayoutInflater原理解析/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          深入了解View（一）——LayoutInflater原理分析
        
      </div>
    </a>
  
  
    <a href="/2016/09/07/Glide深入浅出(一)/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Glide深入浅出（一）——Glide vs Picasso</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Weapp/">Weapp</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/annotations/">annotations</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/app/">app</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/camera/">camera</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dp/">dp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/glide/">glide</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gridview/">gridview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/inflater/">inflater</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/layout/">layout</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/native/">native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/picasso/">picasso</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/support/">support</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/touch/">touch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/view/">view</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/viewgroup/">viewgroup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/volley/">volley</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/weChat/">weChat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webview/">webview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存/">内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数/">函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图片/">图片</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/对象/">对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/布局/">布局</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/支付宝/">支付宝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/框架/">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程/">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/缓存/">缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自定义/">自定义</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计/">设计</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/annotations/" style="font-size: 10px;">annotations</a> <a href="/tags/app/" style="font-size: 10px;">app</a> <a href="/tags/camera/" style="font-size: 12.5px;">camera</a> <a href="/tags/dp/" style="font-size: 10px;">dp</a> <a href="/tags/glide/" style="font-size: 12.5px;">glide</a> <a href="/tags/gridview/" style="font-size: 10px;">gridview</a> <a href="/tags/inflater/" style="font-size: 10px;">inflater</a> <a href="/tags/layout/" style="font-size: 10px;">layout</a> <a href="/tags/native/" style="font-size: 12.5px;">native</a> <a href="/tags/picasso/" style="font-size: 10px;">picasso</a> <a href="/tags/support/" style="font-size: 10px;">support</a> <a href="/tags/touch/" style="font-size: 12.5px;">touch</a> <a href="/tags/view/" style="font-size: 12.5px;">view</a> <a href="/tags/viewgroup/" style="font-size: 10px;">viewgroup</a> <a href="/tags/volley/" style="font-size: 15px;">volley</a> <a href="/tags/weChat/" style="font-size: 10px;">weChat</a> <a href="/tags/webview/" style="font-size: 10px;">webview</a> <a href="/tags/内存/" style="font-size: 10px;">内存</a> <a href="/tags/函数/" style="font-size: 10px;">函数</a> <a href="/tags/图片/" style="font-size: 10px;">图片</a> <a href="/tags/对象/" style="font-size: 10px;">对象</a> <a href="/tags/布局/" style="font-size: 12.5px;">布局</a> <a href="/tags/支付宝/" style="font-size: 10px;">支付宝</a> <a href="/tags/框架/" style="font-size: 10px;">框架</a> <a href="/tags/源码/" style="font-size: 17.5px;">源码</a> <a href="/tags/线程/" style="font-size: 10px;">线程</a> <a href="/tags/缓存/" style="font-size: 12.5px;">缓存</a> <a href="/tags/网络/" style="font-size: 10px;">网络</a> <a href="/tags/自定义/" style="font-size: 10px;">自定义</a> <a href="/tags/设计/" style="font-size: 10px;">设计</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/12/01/基于ReactNative和Realm的开源项目/">自定义相机遇到的坑总结</a>
          </li>
        
          <li>
            <a href="/2016/12/01/自定义相机踩过的坑/">自定义相机踩过的坑</a>
          </li>
        
          <li>
            <a href="/2016/09/26/微信小程序学习资料汇总/">微信小程序学习资料汇总</a>
          </li>
        
          <li>
            <a href="/2016/09/26/一个自定义的GridLayout/">一个自定义的GridLayout</a>
          </li>
        
          <li>
            <a href="/2016/09/13/LayoutInflater原理解析/">深入了解View（一）——LayoutInflater原理分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>